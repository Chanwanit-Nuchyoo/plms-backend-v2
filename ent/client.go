// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"plms-backend/ent/migrate"

	"plms-backend/ent/class"
	"plms-backend/ent/class_lab_status"
	"plms-backend/ent/class_user_role"
	"plms-backend/ent/course"
	"plms-backend/ent/lab"
	"plms-backend/ent/lab_problem"
	"plms-backend/ent/lab_problem_submission"
	"plms-backend/ent/post"
	"plms-backend/ent/testcase"
	"plms-backend/ent/testcase_submission"
	"plms-backend/ent/topic"
	"plms-backend/ent/topic_file_mats"
	"plms-backend/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Class is the client for interacting with the Class builders.
	Class *ClassClient
	// Class_Lab_Status is the client for interacting with the Class_Lab_Status builders.
	Class_Lab_Status *ClassLabStatusClient
	// Class_User_Role is the client for interacting with the Class_User_Role builders.
	Class_User_Role *ClassUserRoleClient
	// Course is the client for interacting with the Course builders.
	Course *CourseClient
	// Lab is the client for interacting with the Lab builders.
	Lab *LabClient
	// Lab_Problem is the client for interacting with the Lab_Problem builders.
	Lab_Problem *LabProblemClient
	// Lab_Problem_Submission is the client for interacting with the Lab_Problem_Submission builders.
	Lab_Problem_Submission *LabProblemSubmissionClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// Testcase is the client for interacting with the Testcase builders.
	Testcase *TestcaseClient
	// Testcase_Submission is the client for interacting with the Testcase_Submission builders.
	Testcase_Submission *TestcaseSubmissionClient
	// Topic is the client for interacting with the Topic builders.
	Topic *TopicClient
	// Topic_File_Mats is the client for interacting with the Topic_File_Mats builders.
	Topic_File_Mats *TopicFileMatsClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Class = NewClassClient(c.config)
	c.Class_Lab_Status = NewClassLabStatusClient(c.config)
	c.Class_User_Role = NewClassUserRoleClient(c.config)
	c.Course = NewCourseClient(c.config)
	c.Lab = NewLabClient(c.config)
	c.Lab_Problem = NewLabProblemClient(c.config)
	c.Lab_Problem_Submission = NewLabProblemSubmissionClient(c.config)
	c.Post = NewPostClient(c.config)
	c.Testcase = NewTestcaseClient(c.config)
	c.Testcase_Submission = NewTestcaseSubmissionClient(c.config)
	c.Topic = NewTopicClient(c.config)
	c.Topic_File_Mats = NewTopicFileMatsClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Class:                  NewClassClient(cfg),
		Class_Lab_Status:       NewClassLabStatusClient(cfg),
		Class_User_Role:        NewClassUserRoleClient(cfg),
		Course:                 NewCourseClient(cfg),
		Lab:                    NewLabClient(cfg),
		Lab_Problem:            NewLabProblemClient(cfg),
		Lab_Problem_Submission: NewLabProblemSubmissionClient(cfg),
		Post:                   NewPostClient(cfg),
		Testcase:               NewTestcaseClient(cfg),
		Testcase_Submission:    NewTestcaseSubmissionClient(cfg),
		Topic:                  NewTopicClient(cfg),
		Topic_File_Mats:        NewTopicFileMatsClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Class:                  NewClassClient(cfg),
		Class_Lab_Status:       NewClassLabStatusClient(cfg),
		Class_User_Role:        NewClassUserRoleClient(cfg),
		Course:                 NewCourseClient(cfg),
		Lab:                    NewLabClient(cfg),
		Lab_Problem:            NewLabProblemClient(cfg),
		Lab_Problem_Submission: NewLabProblemSubmissionClient(cfg),
		Post:                   NewPostClient(cfg),
		Testcase:               NewTestcaseClient(cfg),
		Testcase_Submission:    NewTestcaseSubmissionClient(cfg),
		Topic:                  NewTopicClient(cfg),
		Topic_File_Mats:        NewTopicFileMatsClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Class.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Class, c.Class_Lab_Status, c.Class_User_Role, c.Course, c.Lab, c.Lab_Problem,
		c.Lab_Problem_Submission, c.Post, c.Testcase, c.Testcase_Submission, c.Topic,
		c.Topic_File_Mats, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Class, c.Class_Lab_Status, c.Class_User_Role, c.Course, c.Lab, c.Lab_Problem,
		c.Lab_Problem_Submission, c.Post, c.Testcase, c.Testcase_Submission, c.Topic,
		c.Topic_File_Mats, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ClassMutation:
		return c.Class.mutate(ctx, m)
	case *ClassLabStatusMutation:
		return c.Class_Lab_Status.mutate(ctx, m)
	case *ClassUserRoleMutation:
		return c.Class_User_Role.mutate(ctx, m)
	case *CourseMutation:
		return c.Course.mutate(ctx, m)
	case *LabMutation:
		return c.Lab.mutate(ctx, m)
	case *LabProblemMutation:
		return c.Lab_Problem.mutate(ctx, m)
	case *LabProblemSubmissionMutation:
		return c.Lab_Problem_Submission.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *TestcaseMutation:
		return c.Testcase.mutate(ctx, m)
	case *TestcaseSubmissionMutation:
		return c.Testcase_Submission.mutate(ctx, m)
	case *TopicMutation:
		return c.Topic.mutate(ctx, m)
	case *TopicFileMatsMutation:
		return c.Topic_File_Mats.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ClassClient is a client for the Class schema.
type ClassClient struct {
	config
}

// NewClassClient returns a client for the Class from the given config.
func NewClassClient(c config) *ClassClient {
	return &ClassClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `class.Hooks(f(g(h())))`.
func (c *ClassClient) Use(hooks ...Hook) {
	c.hooks.Class = append(c.hooks.Class, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `class.Intercept(f(g(h())))`.
func (c *ClassClient) Intercept(interceptors ...Interceptor) {
	c.inters.Class = append(c.inters.Class, interceptors...)
}

// Create returns a builder for creating a Class entity.
func (c *ClassClient) Create() *ClassCreate {
	mutation := newClassMutation(c.config, OpCreate)
	return &ClassCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Class entities.
func (c *ClassClient) CreateBulk(builders ...*ClassCreate) *ClassCreateBulk {
	return &ClassCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Class.
func (c *ClassClient) Update() *ClassUpdate {
	mutation := newClassMutation(c.config, OpUpdate)
	return &ClassUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassClient) UpdateOne(cl *Class) *ClassUpdateOne {
	mutation := newClassMutation(c.config, OpUpdateOne, withClass(cl))
	return &ClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassClient) UpdateOneID(id int) *ClassUpdateOne {
	mutation := newClassMutation(c.config, OpUpdateOne, withClassID(id))
	return &ClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Class.
func (c *ClassClient) Delete() *ClassDelete {
	mutation := newClassMutation(c.config, OpDelete)
	return &ClassDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassClient) DeleteOne(cl *Class) *ClassDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassClient) DeleteOneID(id int) *ClassDeleteOne {
	builder := c.Delete().Where(class.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassDeleteOne{builder}
}

// Query returns a query builder for Class.
func (c *ClassClient) Query() *ClassQuery {
	return &ClassQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClass},
		inters: c.Interceptors(),
	}
}

// Get returns a Class entity by its id.
func (c *ClassClient) Get(ctx context.Context, id int) (*Class, error) {
	return c.Query().Where(class.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassClient) GetX(ctx context.Context, id int) *Class {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Class.
func (c *ClassClient) QueryOwner(cl *Class) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class.OwnerTable, class.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourse queries the course edge of a Class.
func (c *ClassClient) QueryCourse(cl *Class) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class.CourseTable, class.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Class.
func (c *ClassClient) QueryMembers(cl *Class) *ClassUserRoleQuery {
	query := (&ClassUserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(class_user_role.Table, class_user_role.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.MembersTable, class.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a Class.
func (c *ClassClient) QueryPosts(cl *Class) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.PostsTable, class.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClassLabStatuses queries the class_lab_statuses edge of a Class.
func (c *ClassClient) QueryClassLabStatuses(cl *Class) *ClassLabStatusQuery {
	query := (&ClassLabStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(class_lab_status.Table, class_lab_status.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.ClassLabStatusesTable, class.ClassLabStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassClient) Hooks() []Hook {
	return c.hooks.Class
}

// Interceptors returns the client interceptors.
func (c *ClassClient) Interceptors() []Interceptor {
	return c.inters.Class
}

func (c *ClassClient) mutate(ctx context.Context, m *ClassMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Class mutation op: %q", m.Op())
	}
}

// ClassLabStatusClient is a client for the Class_Lab_Status schema.
type ClassLabStatusClient struct {
	config
}

// NewClassLabStatusClient returns a client for the Class_Lab_Status from the given config.
func NewClassLabStatusClient(c config) *ClassLabStatusClient {
	return &ClassLabStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `class_lab_status.Hooks(f(g(h())))`.
func (c *ClassLabStatusClient) Use(hooks ...Hook) {
	c.hooks.Class_Lab_Status = append(c.hooks.Class_Lab_Status, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `class_lab_status.Intercept(f(g(h())))`.
func (c *ClassLabStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.Class_Lab_Status = append(c.inters.Class_Lab_Status, interceptors...)
}

// Create returns a builder for creating a Class_Lab_Status entity.
func (c *ClassLabStatusClient) Create() *ClassLabStatusCreate {
	mutation := newClassLabStatusMutation(c.config, OpCreate)
	return &ClassLabStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Class_Lab_Status entities.
func (c *ClassLabStatusClient) CreateBulk(builders ...*ClassLabStatusCreate) *ClassLabStatusCreateBulk {
	return &ClassLabStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Class_Lab_Status.
func (c *ClassLabStatusClient) Update() *ClassLabStatusUpdate {
	mutation := newClassLabStatusMutation(c.config, OpUpdate)
	return &ClassLabStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassLabStatusClient) UpdateOne(cls *Class_Lab_Status) *ClassLabStatusUpdateOne {
	mutation := newClassLabStatusMutation(c.config, OpUpdateOne, withClass_Lab_Status(cls))
	return &ClassLabStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassLabStatusClient) UpdateOneID(id int) *ClassLabStatusUpdateOne {
	mutation := newClassLabStatusMutation(c.config, OpUpdateOne, withClass_Lab_StatusID(id))
	return &ClassLabStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Class_Lab_Status.
func (c *ClassLabStatusClient) Delete() *ClassLabStatusDelete {
	mutation := newClassLabStatusMutation(c.config, OpDelete)
	return &ClassLabStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassLabStatusClient) DeleteOne(cls *Class_Lab_Status) *ClassLabStatusDeleteOne {
	return c.DeleteOneID(cls.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassLabStatusClient) DeleteOneID(id int) *ClassLabStatusDeleteOne {
	builder := c.Delete().Where(class_lab_status.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassLabStatusDeleteOne{builder}
}

// Query returns a query builder for Class_Lab_Status.
func (c *ClassLabStatusClient) Query() *ClassLabStatusQuery {
	return &ClassLabStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassLabStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a Class_Lab_Status entity by its id.
func (c *ClassLabStatusClient) Get(ctx context.Context, id int) (*Class_Lab_Status, error) {
	return c.Query().Where(class_lab_status.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassLabStatusClient) GetX(ctx context.Context, id int) *Class_Lab_Status {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a Class_Lab_Status.
func (c *ClassLabStatusClient) QueryCourse(cls *Class_Lab_Status) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class_lab_status.Table, class_lab_status.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class_lab_status.CourseTable, class_lab_status.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(cls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClass queries the class edge of a Class_Lab_Status.
func (c *ClassLabStatusClient) QueryClass(cls *Class_Lab_Status) *ClassQuery {
	query := (&ClassClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class_lab_status.Table, class_lab_status.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class_lab_status.ClassTable, class_lab_status.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(cls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLab queries the lab edge of a Class_Lab_Status.
func (c *ClassLabStatusClient) QueryLab(cls *Class_Lab_Status) *LabQuery {
	query := (&LabClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cls.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class_lab_status.Table, class_lab_status.FieldID, id),
			sqlgraph.To(lab.Table, lab.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class_lab_status.LabTable, class_lab_status.LabColumn),
		)
		fromV = sqlgraph.Neighbors(cls.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassLabStatusClient) Hooks() []Hook {
	return c.hooks.Class_Lab_Status
}

// Interceptors returns the client interceptors.
func (c *ClassLabStatusClient) Interceptors() []Interceptor {
	return c.inters.Class_Lab_Status
}

func (c *ClassLabStatusClient) mutate(ctx context.Context, m *ClassLabStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassLabStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassLabStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassLabStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassLabStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Class_Lab_Status mutation op: %q", m.Op())
	}
}

// ClassUserRoleClient is a client for the Class_User_Role schema.
type ClassUserRoleClient struct {
	config
}

// NewClassUserRoleClient returns a client for the Class_User_Role from the given config.
func NewClassUserRoleClient(c config) *ClassUserRoleClient {
	return &ClassUserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `class_user_role.Hooks(f(g(h())))`.
func (c *ClassUserRoleClient) Use(hooks ...Hook) {
	c.hooks.Class_User_Role = append(c.hooks.Class_User_Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `class_user_role.Intercept(f(g(h())))`.
func (c *ClassUserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Class_User_Role = append(c.inters.Class_User_Role, interceptors...)
}

// Create returns a builder for creating a Class_User_Role entity.
func (c *ClassUserRoleClient) Create() *ClassUserRoleCreate {
	mutation := newClassUserRoleMutation(c.config, OpCreate)
	return &ClassUserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Class_User_Role entities.
func (c *ClassUserRoleClient) CreateBulk(builders ...*ClassUserRoleCreate) *ClassUserRoleCreateBulk {
	return &ClassUserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Class_User_Role.
func (c *ClassUserRoleClient) Update() *ClassUserRoleUpdate {
	mutation := newClassUserRoleMutation(c.config, OpUpdate)
	return &ClassUserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassUserRoleClient) UpdateOne(cur *Class_User_Role) *ClassUserRoleUpdateOne {
	mutation := newClassUserRoleMutation(c.config, OpUpdateOne, withClass_User_Role(cur))
	return &ClassUserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassUserRoleClient) UpdateOneID(id int) *ClassUserRoleUpdateOne {
	mutation := newClassUserRoleMutation(c.config, OpUpdateOne, withClass_User_RoleID(id))
	return &ClassUserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Class_User_Role.
func (c *ClassUserRoleClient) Delete() *ClassUserRoleDelete {
	mutation := newClassUserRoleMutation(c.config, OpDelete)
	return &ClassUserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassUserRoleClient) DeleteOne(cur *Class_User_Role) *ClassUserRoleDeleteOne {
	return c.DeleteOneID(cur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassUserRoleClient) DeleteOneID(id int) *ClassUserRoleDeleteOne {
	builder := c.Delete().Where(class_user_role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassUserRoleDeleteOne{builder}
}

// Query returns a query builder for Class_User_Role.
func (c *ClassUserRoleClient) Query() *ClassUserRoleQuery {
	return &ClassUserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Class_User_Role entity by its id.
func (c *ClassUserRoleClient) Get(ctx context.Context, id int) (*Class_User_Role, error) {
	return c.Query().Where(class_user_role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassUserRoleClient) GetX(ctx context.Context, id int) *Class_User_Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Class_User_Role.
func (c *ClassUserRoleClient) QueryUser(cur *Class_User_Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class_user_role.Table, class_user_role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class_user_role.UserTable, class_user_role.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClass queries the class edge of a Class_User_Role.
func (c *ClassUserRoleClient) QueryClass(cur *Class_User_Role) *ClassQuery {
	query := (&ClassClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cur.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class_user_role.Table, class_user_role.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class_user_role.ClassTable, class_user_role.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(cur.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassUserRoleClient) Hooks() []Hook {
	return c.hooks.Class_User_Role
}

// Interceptors returns the client interceptors.
func (c *ClassUserRoleClient) Interceptors() []Interceptor {
	return c.inters.Class_User_Role
}

func (c *ClassUserRoleClient) mutate(ctx context.Context, m *ClassUserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassUserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassUserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassUserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassUserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Class_User_Role mutation op: %q", m.Op())
	}
}

// CourseClient is a client for the Course schema.
type CourseClient struct {
	config
}

// NewCourseClient returns a client for the Course from the given config.
func NewCourseClient(c config) *CourseClient {
	return &CourseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `course.Hooks(f(g(h())))`.
func (c *CourseClient) Use(hooks ...Hook) {
	c.hooks.Course = append(c.hooks.Course, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `course.Intercept(f(g(h())))`.
func (c *CourseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Course = append(c.inters.Course, interceptors...)
}

// Create returns a builder for creating a Course entity.
func (c *CourseClient) Create() *CourseCreate {
	mutation := newCourseMutation(c.config, OpCreate)
	return &CourseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Course entities.
func (c *CourseClient) CreateBulk(builders ...*CourseCreate) *CourseCreateBulk {
	return &CourseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Course.
func (c *CourseClient) Update() *CourseUpdate {
	mutation := newCourseMutation(c.config, OpUpdate)
	return &CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CourseClient) UpdateOne(co *Course) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourse(co))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CourseClient) UpdateOneID(id int) *CourseUpdateOne {
	mutation := newCourseMutation(c.config, OpUpdateOne, withCourseID(id))
	return &CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Course.
func (c *CourseClient) Delete() *CourseDelete {
	mutation := newCourseMutation(c.config, OpDelete)
	return &CourseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CourseClient) DeleteOne(co *Course) *CourseDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CourseClient) DeleteOneID(id int) *CourseDeleteOne {
	builder := c.Delete().Where(course.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CourseDeleteOne{builder}
}

// Query returns a query builder for Course.
func (c *CourseClient) Query() *CourseQuery {
	return &CourseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCourse},
		inters: c.Interceptors(),
	}
}

// Get returns a Course entity by its id.
func (c *CourseClient) Get(ctx context.Context, id int) (*Course, error) {
	return c.Query().Where(course.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CourseClient) GetX(ctx context.Context, id int) *Course {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Course.
func (c *CourseClient) QueryOwner(co *Course) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, course.OwnerTable, course.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClasses queries the classes edge of a Course.
func (c *CourseClient) QueryClasses(co *Course) *ClassQuery {
	query := (&ClassClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.ClassesTable, course.ClassesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLabs queries the labs edge of a Course.
func (c *CourseClient) QueryLabs(co *Course) *LabQuery {
	query := (&LabClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(lab.Table, lab.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.LabsTable, course.LabsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTopics queries the topics edge of a Course.
func (c *CourseClient) QueryTopics(co *Course) *TopicQuery {
	query := (&TopicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(topic.Table, topic.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.TopicsTable, course.TopicsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCourseLabStatuses queries the course_lab_statuses edge of a Course.
func (c *CourseClient) QueryCourseLabStatuses(co *Course) *ClassLabStatusQuery {
	query := (&ClassLabStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(course.Table, course.FieldID, id),
			sqlgraph.To(class_lab_status.Table, class_lab_status.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, course.CourseLabStatusesTable, course.CourseLabStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CourseClient) Hooks() []Hook {
	return c.hooks.Course
}

// Interceptors returns the client interceptors.
func (c *CourseClient) Interceptors() []Interceptor {
	return c.inters.Course
}

func (c *CourseClient) mutate(ctx context.Context, m *CourseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CourseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CourseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CourseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CourseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Course mutation op: %q", m.Op())
	}
}

// LabClient is a client for the Lab schema.
type LabClient struct {
	config
}

// NewLabClient returns a client for the Lab from the given config.
func NewLabClient(c config) *LabClient {
	return &LabClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lab.Hooks(f(g(h())))`.
func (c *LabClient) Use(hooks ...Hook) {
	c.hooks.Lab = append(c.hooks.Lab, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lab.Intercept(f(g(h())))`.
func (c *LabClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lab = append(c.inters.Lab, interceptors...)
}

// Create returns a builder for creating a Lab entity.
func (c *LabClient) Create() *LabCreate {
	mutation := newLabMutation(c.config, OpCreate)
	return &LabCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lab entities.
func (c *LabClient) CreateBulk(builders ...*LabCreate) *LabCreateBulk {
	return &LabCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lab.
func (c *LabClient) Update() *LabUpdate {
	mutation := newLabMutation(c.config, OpUpdate)
	return &LabUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LabClient) UpdateOne(l *Lab) *LabUpdateOne {
	mutation := newLabMutation(c.config, OpUpdateOne, withLab(l))
	return &LabUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LabClient) UpdateOneID(id int) *LabUpdateOne {
	mutation := newLabMutation(c.config, OpUpdateOne, withLabID(id))
	return &LabUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lab.
func (c *LabClient) Delete() *LabDelete {
	mutation := newLabMutation(c.config, OpDelete)
	return &LabDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LabClient) DeleteOne(l *Lab) *LabDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LabClient) DeleteOneID(id int) *LabDeleteOne {
	builder := c.Delete().Where(lab.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LabDeleteOne{builder}
}

// Query returns a query builder for Lab.
func (c *LabClient) Query() *LabQuery {
	return &LabQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLab},
		inters: c.Interceptors(),
	}
}

// Get returns a Lab entity by its id.
func (c *LabClient) Get(ctx context.Context, id int) (*Lab, error) {
	return c.Query().Where(lab.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LabClient) GetX(ctx context.Context, id int) *Lab {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a Lab.
func (c *LabClient) QueryCourse(l *Lab) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab.Table, lab.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lab.CourseTable, lab.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLabProblems queries the lab_problems edge of a Lab.
func (c *LabClient) QueryLabProblems(l *Lab) *LabProblemQuery {
	query := (&LabProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab.Table, lab.FieldID, id),
			sqlgraph.To(lab_problem.Table, lab_problem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lab.LabProblemsTable, lab.LabProblemsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLabStatuses queries the lab_statuses edge of a Lab.
func (c *LabClient) QueryLabStatuses(l *Lab) *ClassLabStatusQuery {
	query := (&ClassLabStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab.Table, lab.FieldID, id),
			sqlgraph.To(class_lab_status.Table, class_lab_status.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lab.LabStatusesTable, lab.LabStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LabClient) Hooks() []Hook {
	return c.hooks.Lab
}

// Interceptors returns the client interceptors.
func (c *LabClient) Interceptors() []Interceptor {
	return c.inters.Lab
}

func (c *LabClient) mutate(ctx context.Context, m *LabMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LabCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LabUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LabUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LabDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lab mutation op: %q", m.Op())
	}
}

// LabProblemClient is a client for the Lab_Problem schema.
type LabProblemClient struct {
	config
}

// NewLabProblemClient returns a client for the Lab_Problem from the given config.
func NewLabProblemClient(c config) *LabProblemClient {
	return &LabProblemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lab_problem.Hooks(f(g(h())))`.
func (c *LabProblemClient) Use(hooks ...Hook) {
	c.hooks.Lab_Problem = append(c.hooks.Lab_Problem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lab_problem.Intercept(f(g(h())))`.
func (c *LabProblemClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lab_Problem = append(c.inters.Lab_Problem, interceptors...)
}

// Create returns a builder for creating a Lab_Problem entity.
func (c *LabProblemClient) Create() *LabProblemCreate {
	mutation := newLabProblemMutation(c.config, OpCreate)
	return &LabProblemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lab_Problem entities.
func (c *LabProblemClient) CreateBulk(builders ...*LabProblemCreate) *LabProblemCreateBulk {
	return &LabProblemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lab_Problem.
func (c *LabProblemClient) Update() *LabProblemUpdate {
	mutation := newLabProblemMutation(c.config, OpUpdate)
	return &LabProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LabProblemClient) UpdateOne(lp *Lab_Problem) *LabProblemUpdateOne {
	mutation := newLabProblemMutation(c.config, OpUpdateOne, withLab_Problem(lp))
	return &LabProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LabProblemClient) UpdateOneID(id int) *LabProblemUpdateOne {
	mutation := newLabProblemMutation(c.config, OpUpdateOne, withLab_ProblemID(id))
	return &LabProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lab_Problem.
func (c *LabProblemClient) Delete() *LabProblemDelete {
	mutation := newLabProblemMutation(c.config, OpDelete)
	return &LabProblemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LabProblemClient) DeleteOne(lp *Lab_Problem) *LabProblemDeleteOne {
	return c.DeleteOneID(lp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LabProblemClient) DeleteOneID(id int) *LabProblemDeleteOne {
	builder := c.Delete().Where(lab_problem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LabProblemDeleteOne{builder}
}

// Query returns a query builder for Lab_Problem.
func (c *LabProblemClient) Query() *LabProblemQuery {
	return &LabProblemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLabProblem},
		inters: c.Interceptors(),
	}
}

// Get returns a Lab_Problem entity by its id.
func (c *LabProblemClient) Get(ctx context.Context, id int) (*Lab_Problem, error) {
	return c.Query().Where(lab_problem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LabProblemClient) GetX(ctx context.Context, id int) *Lab_Problem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLab queries the lab edge of a Lab_Problem.
func (c *LabProblemClient) QueryLab(lp *Lab_Problem) *LabQuery {
	query := (&LabClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab_problem.Table, lab_problem.FieldID, id),
			sqlgraph.To(lab.Table, lab.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lab_problem.LabTable, lab_problem.LabColumn),
		)
		fromV = sqlgraph.Neighbors(lp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestcases queries the testcases edge of a Lab_Problem.
func (c *LabProblemClient) QueryTestcases(lp *Lab_Problem) *TestcaseQuery {
	query := (&TestcaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab_problem.Table, lab_problem.FieldID, id),
			sqlgraph.To(testcase.Table, testcase.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lab_problem.TestcasesTable, lab_problem.TestcasesColumn),
		)
		fromV = sqlgraph.Neighbors(lp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LabProblemClient) Hooks() []Hook {
	return c.hooks.Lab_Problem
}

// Interceptors returns the client interceptors.
func (c *LabProblemClient) Interceptors() []Interceptor {
	return c.inters.Lab_Problem
}

func (c *LabProblemClient) mutate(ctx context.Context, m *LabProblemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LabProblemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LabProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LabProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LabProblemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lab_Problem mutation op: %q", m.Op())
	}
}

// LabProblemSubmissionClient is a client for the Lab_Problem_Submission schema.
type LabProblemSubmissionClient struct {
	config
}

// NewLabProblemSubmissionClient returns a client for the Lab_Problem_Submission from the given config.
func NewLabProblemSubmissionClient(c config) *LabProblemSubmissionClient {
	return &LabProblemSubmissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lab_problem_submission.Hooks(f(g(h())))`.
func (c *LabProblemSubmissionClient) Use(hooks ...Hook) {
	c.hooks.Lab_Problem_Submission = append(c.hooks.Lab_Problem_Submission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lab_problem_submission.Intercept(f(g(h())))`.
func (c *LabProblemSubmissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lab_Problem_Submission = append(c.inters.Lab_Problem_Submission, interceptors...)
}

// Create returns a builder for creating a Lab_Problem_Submission entity.
func (c *LabProblemSubmissionClient) Create() *LabProblemSubmissionCreate {
	mutation := newLabProblemSubmissionMutation(c.config, OpCreate)
	return &LabProblemSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lab_Problem_Submission entities.
func (c *LabProblemSubmissionClient) CreateBulk(builders ...*LabProblemSubmissionCreate) *LabProblemSubmissionCreateBulk {
	return &LabProblemSubmissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lab_Problem_Submission.
func (c *LabProblemSubmissionClient) Update() *LabProblemSubmissionUpdate {
	mutation := newLabProblemSubmissionMutation(c.config, OpUpdate)
	return &LabProblemSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LabProblemSubmissionClient) UpdateOne(lps *Lab_Problem_Submission) *LabProblemSubmissionUpdateOne {
	mutation := newLabProblemSubmissionMutation(c.config, OpUpdateOne, withLab_Problem_Submission(lps))
	return &LabProblemSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LabProblemSubmissionClient) UpdateOneID(id int) *LabProblemSubmissionUpdateOne {
	mutation := newLabProblemSubmissionMutation(c.config, OpUpdateOne, withLab_Problem_SubmissionID(id))
	return &LabProblemSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lab_Problem_Submission.
func (c *LabProblemSubmissionClient) Delete() *LabProblemSubmissionDelete {
	mutation := newLabProblemSubmissionMutation(c.config, OpDelete)
	return &LabProblemSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LabProblemSubmissionClient) DeleteOne(lps *Lab_Problem_Submission) *LabProblemSubmissionDeleteOne {
	return c.DeleteOneID(lps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LabProblemSubmissionClient) DeleteOneID(id int) *LabProblemSubmissionDeleteOne {
	builder := c.Delete().Where(lab_problem_submission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LabProblemSubmissionDeleteOne{builder}
}

// Query returns a query builder for Lab_Problem_Submission.
func (c *LabProblemSubmissionClient) Query() *LabProblemSubmissionQuery {
	return &LabProblemSubmissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLabProblemSubmission},
		inters: c.Interceptors(),
	}
}

// Get returns a Lab_Problem_Submission entity by its id.
func (c *LabProblemSubmissionClient) Get(ctx context.Context, id int) (*Lab_Problem_Submission, error) {
	return c.Query().Where(lab_problem_submission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LabProblemSubmissionClient) GetX(ctx context.Context, id int) *Lab_Problem_Submission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Lab_Problem_Submission.
func (c *LabProblemSubmissionClient) QueryOwner(lps *Lab_Problem_Submission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab_problem_submission.Table, lab_problem_submission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lab_problem_submission.OwnerTable, lab_problem_submission.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(lps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestcaseSubmissions queries the testcase_submissions edge of a Lab_Problem_Submission.
func (c *LabProblemSubmissionClient) QueryTestcaseSubmissions(lps *Lab_Problem_Submission) *TestcaseSubmissionQuery {
	query := (&TestcaseSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lab_problem_submission.Table, lab_problem_submission.FieldID, id),
			sqlgraph.To(testcase_submission.Table, testcase_submission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lab_problem_submission.TestcaseSubmissionsTable, lab_problem_submission.TestcaseSubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(lps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LabProblemSubmissionClient) Hooks() []Hook {
	return c.hooks.Lab_Problem_Submission
}

// Interceptors returns the client interceptors.
func (c *LabProblemSubmissionClient) Interceptors() []Interceptor {
	return c.inters.Lab_Problem_Submission
}

func (c *LabProblemSubmissionClient) mutate(ctx context.Context, m *LabProblemSubmissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LabProblemSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LabProblemSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LabProblemSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LabProblemSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lab_Problem_Submission mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(po *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(po))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id int) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(po *Post) *PostDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id int) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id int) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id int) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClass queries the class edge of a Post.
func (c *PostClient) QueryClass(po *Post) *ClassQuery {
	query := (&ClassClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.ClassTable, post.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a Post.
func (c *PostClient) QueryAuthor(po *Post) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.AuthorTable, post.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	return c.hooks.Post
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// TestcaseClient is a client for the Testcase schema.
type TestcaseClient struct {
	config
}

// NewTestcaseClient returns a client for the Testcase from the given config.
func NewTestcaseClient(c config) *TestcaseClient {
	return &TestcaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase.Hooks(f(g(h())))`.
func (c *TestcaseClient) Use(hooks ...Hook) {
	c.hooks.Testcase = append(c.hooks.Testcase, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testcase.Intercept(f(g(h())))`.
func (c *TestcaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Testcase = append(c.inters.Testcase, interceptors...)
}

// Create returns a builder for creating a Testcase entity.
func (c *TestcaseClient) Create() *TestcaseCreate {
	mutation := newTestcaseMutation(c.config, OpCreate)
	return &TestcaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Testcase entities.
func (c *TestcaseClient) CreateBulk(builders ...*TestcaseCreate) *TestcaseCreateBulk {
	return &TestcaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Testcase.
func (c *TestcaseClient) Update() *TestcaseUpdate {
	mutation := newTestcaseMutation(c.config, OpUpdate)
	return &TestcaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestcaseClient) UpdateOne(t *Testcase) *TestcaseUpdateOne {
	mutation := newTestcaseMutation(c.config, OpUpdateOne, withTestcase(t))
	return &TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestcaseClient) UpdateOneID(id int) *TestcaseUpdateOne {
	mutation := newTestcaseMutation(c.config, OpUpdateOne, withTestcaseID(id))
	return &TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Testcase.
func (c *TestcaseClient) Delete() *TestcaseDelete {
	mutation := newTestcaseMutation(c.config, OpDelete)
	return &TestcaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestcaseClient) DeleteOne(t *Testcase) *TestcaseDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestcaseClient) DeleteOneID(id int) *TestcaseDeleteOne {
	builder := c.Delete().Where(testcase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestcaseDeleteOne{builder}
}

// Query returns a query builder for Testcase.
func (c *TestcaseClient) Query() *TestcaseQuery {
	return &TestcaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestcase},
		inters: c.Interceptors(),
	}
}

// Get returns a Testcase entity by its id.
func (c *TestcaseClient) Get(ctx context.Context, id int) (*Testcase, error) {
	return c.Query().Where(testcase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestcaseClient) GetX(ctx context.Context, id int) *Testcase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLabProblem queries the lab_problem edge of a Testcase.
func (c *TestcaseClient) QueryLabProblem(t *Testcase) *LabProblemQuery {
	query := (&LabProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase.Table, testcase.FieldID, id),
			sqlgraph.To(lab_problem.Table, lab_problem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testcase.LabProblemTable, testcase.LabProblemColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestcaseSubmissions queries the testcase_submissions edge of a Testcase.
func (c *TestcaseClient) QueryTestcaseSubmissions(t *Testcase) *TestcaseSubmissionQuery {
	query := (&TestcaseSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase.Table, testcase.FieldID, id),
			sqlgraph.To(testcase_submission.Table, testcase_submission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, testcase.TestcaseSubmissionsTable, testcase.TestcaseSubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestcaseClient) Hooks() []Hook {
	return c.hooks.Testcase
}

// Interceptors returns the client interceptors.
func (c *TestcaseClient) Interceptors() []Interceptor {
	return c.inters.Testcase
}

func (c *TestcaseClient) mutate(ctx context.Context, m *TestcaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestcaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestcaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestcaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Testcase mutation op: %q", m.Op())
	}
}

// TestcaseSubmissionClient is a client for the Testcase_Submission schema.
type TestcaseSubmissionClient struct {
	config
}

// NewTestcaseSubmissionClient returns a client for the Testcase_Submission from the given config.
func NewTestcaseSubmissionClient(c config) *TestcaseSubmissionClient {
	return &TestcaseSubmissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase_submission.Hooks(f(g(h())))`.
func (c *TestcaseSubmissionClient) Use(hooks ...Hook) {
	c.hooks.Testcase_Submission = append(c.hooks.Testcase_Submission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testcase_submission.Intercept(f(g(h())))`.
func (c *TestcaseSubmissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Testcase_Submission = append(c.inters.Testcase_Submission, interceptors...)
}

// Create returns a builder for creating a Testcase_Submission entity.
func (c *TestcaseSubmissionClient) Create() *TestcaseSubmissionCreate {
	mutation := newTestcaseSubmissionMutation(c.config, OpCreate)
	return &TestcaseSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Testcase_Submission entities.
func (c *TestcaseSubmissionClient) CreateBulk(builders ...*TestcaseSubmissionCreate) *TestcaseSubmissionCreateBulk {
	return &TestcaseSubmissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Testcase_Submission.
func (c *TestcaseSubmissionClient) Update() *TestcaseSubmissionUpdate {
	mutation := newTestcaseSubmissionMutation(c.config, OpUpdate)
	return &TestcaseSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestcaseSubmissionClient) UpdateOne(ts *Testcase_Submission) *TestcaseSubmissionUpdateOne {
	mutation := newTestcaseSubmissionMutation(c.config, OpUpdateOne, withTestcase_Submission(ts))
	return &TestcaseSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestcaseSubmissionClient) UpdateOneID(id int) *TestcaseSubmissionUpdateOne {
	mutation := newTestcaseSubmissionMutation(c.config, OpUpdateOne, withTestcase_SubmissionID(id))
	return &TestcaseSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Testcase_Submission.
func (c *TestcaseSubmissionClient) Delete() *TestcaseSubmissionDelete {
	mutation := newTestcaseSubmissionMutation(c.config, OpDelete)
	return &TestcaseSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestcaseSubmissionClient) DeleteOne(ts *Testcase_Submission) *TestcaseSubmissionDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestcaseSubmissionClient) DeleteOneID(id int) *TestcaseSubmissionDeleteOne {
	builder := c.Delete().Where(testcase_submission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestcaseSubmissionDeleteOne{builder}
}

// Query returns a query builder for Testcase_Submission.
func (c *TestcaseSubmissionClient) Query() *TestcaseSubmissionQuery {
	return &TestcaseSubmissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestcaseSubmission},
		inters: c.Interceptors(),
	}
}

// Get returns a Testcase_Submission entity by its id.
func (c *TestcaseSubmissionClient) Get(ctx context.Context, id int) (*Testcase_Submission, error) {
	return c.Query().Where(testcase_submission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestcaseSubmissionClient) GetX(ctx context.Context, id int) *Testcase_Submission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTestcase queries the testcase edge of a Testcase_Submission.
func (c *TestcaseSubmissionClient) QueryTestcase(ts *Testcase_Submission) *TestcaseQuery {
	query := (&TestcaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase_submission.Table, testcase_submission.FieldID, id),
			sqlgraph.To(testcase.Table, testcase.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testcase_submission.TestcaseTable, testcase_submission.TestcaseColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubmission queries the submission edge of a Testcase_Submission.
func (c *TestcaseSubmissionClient) QuerySubmission(ts *Testcase_Submission) *LabProblemSubmissionQuery {
	query := (&LabProblemSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testcase_submission.Table, testcase_submission.FieldID, id),
			sqlgraph.To(lab_problem_submission.Table, lab_problem_submission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testcase_submission.SubmissionTable, testcase_submission.SubmissionColumn),
		)
		fromV = sqlgraph.Neighbors(ts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestcaseSubmissionClient) Hooks() []Hook {
	return c.hooks.Testcase_Submission
}

// Interceptors returns the client interceptors.
func (c *TestcaseSubmissionClient) Interceptors() []Interceptor {
	return c.inters.Testcase_Submission
}

func (c *TestcaseSubmissionClient) mutate(ctx context.Context, m *TestcaseSubmissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestcaseSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestcaseSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestcaseSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestcaseSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Testcase_Submission mutation op: %q", m.Op())
	}
}

// TopicClient is a client for the Topic schema.
type TopicClient struct {
	config
}

// NewTopicClient returns a client for the Topic from the given config.
func NewTopicClient(c config) *TopicClient {
	return &TopicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topic.Hooks(f(g(h())))`.
func (c *TopicClient) Use(hooks ...Hook) {
	c.hooks.Topic = append(c.hooks.Topic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topic.Intercept(f(g(h())))`.
func (c *TopicClient) Intercept(interceptors ...Interceptor) {
	c.inters.Topic = append(c.inters.Topic, interceptors...)
}

// Create returns a builder for creating a Topic entity.
func (c *TopicClient) Create() *TopicCreate {
	mutation := newTopicMutation(c.config, OpCreate)
	return &TopicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Topic entities.
func (c *TopicClient) CreateBulk(builders ...*TopicCreate) *TopicCreateBulk {
	return &TopicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Topic.
func (c *TopicClient) Update() *TopicUpdate {
	mutation := newTopicMutation(c.config, OpUpdate)
	return &TopicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopicClient) UpdateOne(t *Topic) *TopicUpdateOne {
	mutation := newTopicMutation(c.config, OpUpdateOne, withTopic(t))
	return &TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopicClient) UpdateOneID(id int) *TopicUpdateOne {
	mutation := newTopicMutation(c.config, OpUpdateOne, withTopicID(id))
	return &TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Topic.
func (c *TopicClient) Delete() *TopicDelete {
	mutation := newTopicMutation(c.config, OpDelete)
	return &TopicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopicClient) DeleteOne(t *Topic) *TopicDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopicClient) DeleteOneID(id int) *TopicDeleteOne {
	builder := c.Delete().Where(topic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopicDeleteOne{builder}
}

// Query returns a query builder for Topic.
func (c *TopicClient) Query() *TopicQuery {
	return &TopicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopic},
		inters: c.Interceptors(),
	}
}

// Get returns a Topic entity by its id.
func (c *TopicClient) Get(ctx context.Context, id int) (*Topic, error) {
	return c.Query().Where(topic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopicClient) GetX(ctx context.Context, id int) *Topic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourse queries the course edge of a Topic.
func (c *TopicClient) QueryCourse(t *Topic) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic.Table, topic.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, topic.CourseTable, topic.CourseColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a Topic.
func (c *TopicClient) QueryFiles(t *Topic) *TopicFileMatsQuery {
	query := (&TopicFileMatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic.Table, topic.FieldID, id),
			sqlgraph.To(topic_file_mats.Table, topic_file_mats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, topic.FilesTable, topic.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TopicClient) Hooks() []Hook {
	return c.hooks.Topic
}

// Interceptors returns the client interceptors.
func (c *TopicClient) Interceptors() []Interceptor {
	return c.inters.Topic
}

func (c *TopicClient) mutate(ctx context.Context, m *TopicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Topic mutation op: %q", m.Op())
	}
}

// TopicFileMatsClient is a client for the Topic_File_Mats schema.
type TopicFileMatsClient struct {
	config
}

// NewTopicFileMatsClient returns a client for the Topic_File_Mats from the given config.
func NewTopicFileMatsClient(c config) *TopicFileMatsClient {
	return &TopicFileMatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topic_file_mats.Hooks(f(g(h())))`.
func (c *TopicFileMatsClient) Use(hooks ...Hook) {
	c.hooks.Topic_File_Mats = append(c.hooks.Topic_File_Mats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topic_file_mats.Intercept(f(g(h())))`.
func (c *TopicFileMatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Topic_File_Mats = append(c.inters.Topic_File_Mats, interceptors...)
}

// Create returns a builder for creating a Topic_File_Mats entity.
func (c *TopicFileMatsClient) Create() *TopicFileMatsCreate {
	mutation := newTopicFileMatsMutation(c.config, OpCreate)
	return &TopicFileMatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Topic_File_Mats entities.
func (c *TopicFileMatsClient) CreateBulk(builders ...*TopicFileMatsCreate) *TopicFileMatsCreateBulk {
	return &TopicFileMatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Topic_File_Mats.
func (c *TopicFileMatsClient) Update() *TopicFileMatsUpdate {
	mutation := newTopicFileMatsMutation(c.config, OpUpdate)
	return &TopicFileMatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopicFileMatsClient) UpdateOne(tfm *Topic_File_Mats) *TopicFileMatsUpdateOne {
	mutation := newTopicFileMatsMutation(c.config, OpUpdateOne, withTopic_File_Mats(tfm))
	return &TopicFileMatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopicFileMatsClient) UpdateOneID(id int) *TopicFileMatsUpdateOne {
	mutation := newTopicFileMatsMutation(c.config, OpUpdateOne, withTopic_File_MatsID(id))
	return &TopicFileMatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Topic_File_Mats.
func (c *TopicFileMatsClient) Delete() *TopicFileMatsDelete {
	mutation := newTopicFileMatsMutation(c.config, OpDelete)
	return &TopicFileMatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopicFileMatsClient) DeleteOne(tfm *Topic_File_Mats) *TopicFileMatsDeleteOne {
	return c.DeleteOneID(tfm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopicFileMatsClient) DeleteOneID(id int) *TopicFileMatsDeleteOne {
	builder := c.Delete().Where(topic_file_mats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopicFileMatsDeleteOne{builder}
}

// Query returns a query builder for Topic_File_Mats.
func (c *TopicFileMatsClient) Query() *TopicFileMatsQuery {
	return &TopicFileMatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopicFileMats},
		inters: c.Interceptors(),
	}
}

// Get returns a Topic_File_Mats entity by its id.
func (c *TopicFileMatsClient) Get(ctx context.Context, id int) (*Topic_File_Mats, error) {
	return c.Query().Where(topic_file_mats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopicFileMatsClient) GetX(ctx context.Context, id int) *Topic_File_Mats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTopic queries the topic edge of a Topic_File_Mats.
func (c *TopicFileMatsClient) QueryTopic(tfm *Topic_File_Mats) *TopicQuery {
	query := (&TopicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic_file_mats.Table, topic_file_mats.FieldID, id),
			sqlgraph.To(topic.Table, topic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, topic_file_mats.TopicTable, topic_file_mats.TopicColumn),
		)
		fromV = sqlgraph.Neighbors(tfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TopicFileMatsClient) Hooks() []Hook {
	return c.hooks.Topic_File_Mats
}

// Interceptors returns the client interceptors.
func (c *TopicFileMatsClient) Interceptors() []Interceptor {
	return c.inters.Topic_File_Mats
}

func (c *TopicFileMatsClient) mutate(ctx context.Context, m *TopicFileMatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopicFileMatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopicFileMatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopicFileMatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopicFileMatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Topic_File_Mats mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCourses queries the courses edge of a User.
func (c *UserClient) QueryCourses(u *User) *CourseQuery {
	query := (&CourseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(course.Table, course.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CoursesTable, user.CoursesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedClasses queries the owned_classes edge of a User.
func (c *UserClient) QueryOwnedClasses(u *User) *ClassQuery {
	query := (&ClassClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OwnedClassesTable, user.OwnedClassesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoinedClasses queries the joined_classes edge of a User.
func (c *UserClient) QueryJoinedClasses(u *User) *ClassUserRoleQuery {
	query := (&ClassUserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(class_user_role.Table, class_user_role.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JoinedClassesTable, user.JoinedClassesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedPosts queries the owned_posts edge of a User.
func (c *UserClient) QueryOwnedPosts(u *User) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OwnedPostsTable, user.OwnedPostsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLabProblemSubmissions queries the lab_problem_submissions edge of a User.
func (c *UserClient) QueryLabProblemSubmissions(u *User) *LabProblemSubmissionQuery {
	query := (&LabProblemSubmissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(lab_problem_submission.Table, lab_problem_submission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LabProblemSubmissionsTable, user.LabProblemSubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Class, Class_Lab_Status, Class_User_Role, Course, Lab, Lab_Problem,
		Lab_Problem_Submission, Post, Testcase, Testcase_Submission, Topic,
		Topic_File_Mats, User []ent.Hook
	}
	inters struct {
		Class, Class_Lab_Status, Class_User_Role, Course, Lab, Lab_Problem,
		Lab_Problem_Submission, Post, Testcase, Testcase_Submission, Topic,
		Topic_File_Mats, User []ent.Interceptor
	}
)
