// Code generated by ent, DO NOT EDIT.

package ent

import (
	"plms-backend/ent/class"
	"plms-backend/ent/class_lab_status"
	"plms-backend/ent/class_user_role"
	"plms-backend/ent/course"
	"plms-backend/ent/lab"
	"plms-backend/ent/lab_problem"
	"plms-backend/ent/lab_problem_submission"
	"plms-backend/ent/post"
	"plms-backend/ent/predicate"
	"plms-backend/ent/testcase"
	"plms-backend/ent/testcase_submission"
	"plms-backend/ent/topic"
	"plms-backend/ent/topic_file_mats"
	"plms-backend/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClass                = "Class"
	TypeClassLabStatus       = "Class_Lab_Status"
	TypeClassUserRole        = "Class_User_Role"
	TypeCourse               = "Course"
	TypeLab                  = "Lab"
	TypeLabProblem           = "Lab_Problem"
	TypeLabProblemSubmission = "Lab_Problem_Submission"
	TypePost                 = "Post"
	TypeTestcase             = "Testcase"
	TypeTestcaseSubmission   = "Testcase_Submission"
	TypeTopic                = "Topic"
	TypeTopicFileMats        = "Topic_File_Mats"
	TypeUser                 = "User"
)

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	description               *string
	default_lang              *class.DefaultLang
	dotw                      *class.Dotw
	start_time                *time.Time
	end_time                  *time.Time
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *int
	clearedowner              bool
	course                    *int
	clearedcourse             bool
	members                   map[int]struct{}
	removedmembers            map[int]struct{}
	clearedmembers            bool
	posts                     map[int]struct{}
	removedposts              map[int]struct{}
	clearedposts              bool
	class_lab_statuses        map[int]struct{}
	removedclass_lab_statuses map[int]struct{}
	clearedclass_lab_statuses bool
	done                      bool
	oldValue                  func(context.Context) (*Class, error)
	predicates                []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id int) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner_id" field.
func (m *ClassMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ClassMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ClassMutation) ResetOwnerID() {
	m.owner = nil
}

// SetCourseID sets the "course_id" field.
func (m *ClassMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *ClassMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *ClassMutation) ResetCourseID() {
	m.course = nil
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ClassMutation) ResetDescription() {
	m.description = nil
}

// SetDefaultLang sets the "default_lang" field.
func (m *ClassMutation) SetDefaultLang(cl class.DefaultLang) {
	m.default_lang = &cl
}

// DefaultLang returns the value of the "default_lang" field in the mutation.
func (m *ClassMutation) DefaultLang() (r class.DefaultLang, exists bool) {
	v := m.default_lang
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultLang returns the old "default_lang" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDefaultLang(ctx context.Context) (v class.DefaultLang, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultLang is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultLang requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultLang: %w", err)
	}
	return oldValue.DefaultLang, nil
}

// ResetDefaultLang resets all changes to the "default_lang" field.
func (m *ClassMutation) ResetDefaultLang() {
	m.default_lang = nil
}

// SetDotw sets the "dotw" field.
func (m *ClassMutation) SetDotw(c class.Dotw) {
	m.dotw = &c
}

// Dotw returns the value of the "dotw" field in the mutation.
func (m *ClassMutation) Dotw() (r class.Dotw, exists bool) {
	v := m.dotw
	if v == nil {
		return
	}
	return *v, true
}

// OldDotw returns the old "dotw" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldDotw(ctx context.Context) (v class.Dotw, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDotw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDotw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDotw: %w", err)
	}
	return oldValue.Dotw, nil
}

// ResetDotw resets all changes to the "dotw" field.
func (m *ClassMutation) ResetDotw() {
	m.dotw = nil
}

// SetStartTime sets the "start_time" field.
func (m *ClassMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ClassMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ClassMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ClassMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ClassMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ClassMutation) ResetEndTime() {
	m.end_time = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ClassMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ClassMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ClassMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ClassMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ClassMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ClassMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddMemberIDs adds the "members" edge to the Class_User_Role entity by ids.
func (m *ClassMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Class_User_Role entity.
func (m *ClassMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Class_User_Role entity was cleared.
func (m *ClassMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Class_User_Role entity by IDs.
func (m *ClassMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Class_User_Role entity.
func (m *ClassMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ClassMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ClassMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *ClassMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *ClassMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *ClassMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *ClassMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *ClassMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *ClassMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *ClassMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddClassLabStatusIDs adds the "class_lab_statuses" edge to the Class_Lab_Status entity by ids.
func (m *ClassMutation) AddClassLabStatusIDs(ids ...int) {
	if m.class_lab_statuses == nil {
		m.class_lab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.class_lab_statuses[ids[i]] = struct{}{}
	}
}

// ClearClassLabStatuses clears the "class_lab_statuses" edge to the Class_Lab_Status entity.
func (m *ClassMutation) ClearClassLabStatuses() {
	m.clearedclass_lab_statuses = true
}

// ClassLabStatusesCleared reports if the "class_lab_statuses" edge to the Class_Lab_Status entity was cleared.
func (m *ClassMutation) ClassLabStatusesCleared() bool {
	return m.clearedclass_lab_statuses
}

// RemoveClassLabStatusIDs removes the "class_lab_statuses" edge to the Class_Lab_Status entity by IDs.
func (m *ClassMutation) RemoveClassLabStatusIDs(ids ...int) {
	if m.removedclass_lab_statuses == nil {
		m.removedclass_lab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.class_lab_statuses, ids[i])
		m.removedclass_lab_statuses[ids[i]] = struct{}{}
	}
}

// RemovedClassLabStatuses returns the removed IDs of the "class_lab_statuses" edge to the Class_Lab_Status entity.
func (m *ClassMutation) RemovedClassLabStatusesIDs() (ids []int) {
	for id := range m.removedclass_lab_statuses {
		ids = append(ids, id)
	}
	return
}

// ClassLabStatusesIDs returns the "class_lab_statuses" edge IDs in the mutation.
func (m *ClassMutation) ClassLabStatusesIDs() (ids []int) {
	for id := range m.class_lab_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetClassLabStatuses resets all changes to the "class_lab_statuses" edge.
func (m *ClassMutation) ResetClassLabStatuses() {
	m.class_lab_statuses = nil
	m.clearedclass_lab_statuses = false
	m.removedclass_lab_statuses = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.owner != nil {
		fields = append(fields, class.FieldOwnerID)
	}
	if m.course != nil {
		fields = append(fields, class.FieldCourseID)
	}
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.description != nil {
		fields = append(fields, class.FieldDescription)
	}
	if m.default_lang != nil {
		fields = append(fields, class.FieldDefaultLang)
	}
	if m.dotw != nil {
		fields = append(fields, class.FieldDotw)
	}
	if m.start_time != nil {
		fields = append(fields, class.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, class.FieldEndTime)
	}
	if m.created_at != nil {
		fields = append(fields, class.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, class.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldOwnerID:
		return m.OwnerID()
	case class.FieldCourseID:
		return m.CourseID()
	case class.FieldName:
		return m.Name()
	case class.FieldDescription:
		return m.Description()
	case class.FieldDefaultLang:
		return m.DefaultLang()
	case class.FieldDotw:
		return m.Dotw()
	case class.FieldStartTime:
		return m.StartTime()
	case class.FieldEndTime:
		return m.EndTime()
	case class.FieldCreatedAt:
		return m.CreatedAt()
	case class.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case class.FieldCourseID:
		return m.OldCourseID(ctx)
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldDescription:
		return m.OldDescription(ctx)
	case class.FieldDefaultLang:
		return m.OldDefaultLang(ctx)
	case class.FieldDotw:
		return m.OldDotw(ctx)
	case class.FieldStartTime:
		return m.OldStartTime(ctx)
	case class.FieldEndTime:
		return m.OldEndTime(ctx)
	case class.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case class.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case class.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case class.FieldDefaultLang:
		v, ok := value.(class.DefaultLang)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultLang(v)
		return nil
	case class.FieldDotw:
		v, ok := value.(class.Dotw)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDotw(v)
		return nil
	case class.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case class.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case class.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case class.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case class.FieldCourseID:
		m.ResetCourseID()
		return nil
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldDescription:
		m.ResetDescription()
		return nil
	case class.FieldDefaultLang:
		m.ResetDefaultLang()
		return nil
	case class.FieldDotw:
		m.ResetDotw()
		return nil
	case class.FieldStartTime:
		m.ResetStartTime()
		return nil
	case class.FieldEndTime:
		m.ResetEndTime()
		return nil
	case class.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case class.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, class.EdgeOwner)
	}
	if m.course != nil {
		edges = append(edges, class.EdgeCourse)
	}
	if m.members != nil {
		edges = append(edges, class.EdgeMembers)
	}
	if m.posts != nil {
		edges = append(edges, class.EdgePosts)
	}
	if m.class_lab_statuses != nil {
		edges = append(edges, class.EdgeClassLabStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case class.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassLabStatuses:
		ids := make([]ent.Value, 0, len(m.class_lab_statuses))
		for id := range m.class_lab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedmembers != nil {
		edges = append(edges, class.EdgeMembers)
	}
	if m.removedposts != nil {
		edges = append(edges, class.EdgePosts)
	}
	if m.removedclass_lab_statuses != nil {
		edges = append(edges, class.EdgeClassLabStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case class.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeClassLabStatuses:
		ids := make([]ent.Value, 0, len(m.removedclass_lab_statuses))
		for id := range m.removedclass_lab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, class.EdgeOwner)
	}
	if m.clearedcourse {
		edges = append(edges, class.EdgeCourse)
	}
	if m.clearedmembers {
		edges = append(edges, class.EdgeMembers)
	}
	if m.clearedposts {
		edges = append(edges, class.EdgePosts)
	}
	if m.clearedclass_lab_statuses {
		edges = append(edges, class.EdgeClassLabStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeOwner:
		return m.clearedowner
	case class.EdgeCourse:
		return m.clearedcourse
	case class.EdgeMembers:
		return m.clearedmembers
	case class.EdgePosts:
		return m.clearedposts
	case class.EdgeClassLabStatuses:
		return m.clearedclass_lab_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeOwner:
		m.ClearOwner()
		return nil
	case class.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeOwner:
		m.ResetOwner()
		return nil
	case class.EdgeCourse:
		m.ResetCourse()
		return nil
	case class.EdgeMembers:
		m.ResetMembers()
		return nil
	case class.EdgePosts:
		m.ResetPosts()
		return nil
	case class.EdgeClassLabStatuses:
		m.ResetClassLabStatuses()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// ClassLabStatusMutation represents an operation that mutates the Class_Lab_Status nodes in the graph.
type ClassLabStatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	is_open       *bool
	clearedFields map[string]struct{}
	course        *int
	clearedcourse bool
	class         *int
	clearedclass  bool
	lab           *int
	clearedlab    bool
	done          bool
	oldValue      func(context.Context) (*Class_Lab_Status, error)
	predicates    []predicate.Class_Lab_Status
}

var _ ent.Mutation = (*ClassLabStatusMutation)(nil)

// classLabStatusOption allows management of the mutation configuration using functional options.
type classLabStatusOption func(*ClassLabStatusMutation)

// newClassLabStatusMutation creates new mutation for the Class_Lab_Status entity.
func newClassLabStatusMutation(c config, op Op, opts ...classLabStatusOption) *ClassLabStatusMutation {
	m := &ClassLabStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeClassLabStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClass_Lab_StatusID sets the ID field of the mutation.
func withClass_Lab_StatusID(id int) classLabStatusOption {
	return func(m *ClassLabStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Class_Lab_Status
		)
		m.oldValue = func(ctx context.Context) (*Class_Lab_Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class_Lab_Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass_Lab_Status sets the old Class_Lab_Status of the mutation.
func withClass_Lab_Status(node *Class_Lab_Status) classLabStatusOption {
	return func(m *ClassLabStatusMutation) {
		m.oldValue = func(context.Context) (*Class_Lab_Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassLabStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassLabStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassLabStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassLabStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class_Lab_Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCourseID sets the "course_id" field.
func (m *ClassLabStatusMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *ClassLabStatusMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Class_Lab_Status entity.
// If the Class_Lab_Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassLabStatusMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *ClassLabStatusMutation) ResetCourseID() {
	m.course = nil
}

// SetClassID sets the "class_id" field.
func (m *ClassLabStatusMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *ClassLabStatusMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Class_Lab_Status entity.
// If the Class_Lab_Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassLabStatusMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ResetClassID resets all changes to the "class_id" field.
func (m *ClassLabStatusMutation) ResetClassID() {
	m.class = nil
}

// SetLabID sets the "lab_id" field.
func (m *ClassLabStatusMutation) SetLabID(i int) {
	m.lab = &i
}

// LabID returns the value of the "lab_id" field in the mutation.
func (m *ClassLabStatusMutation) LabID() (r int, exists bool) {
	v := m.lab
	if v == nil {
		return
	}
	return *v, true
}

// OldLabID returns the old "lab_id" field's value of the Class_Lab_Status entity.
// If the Class_Lab_Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassLabStatusMutation) OldLabID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabID: %w", err)
	}
	return oldValue.LabID, nil
}

// ResetLabID resets all changes to the "lab_id" field.
func (m *ClassLabStatusMutation) ResetLabID() {
	m.lab = nil
}

// SetIsOpen sets the "is_open" field.
func (m *ClassLabStatusMutation) SetIsOpen(b bool) {
	m.is_open = &b
}

// IsOpen returns the value of the "is_open" field in the mutation.
func (m *ClassLabStatusMutation) IsOpen() (r bool, exists bool) {
	v := m.is_open
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOpen returns the old "is_open" field's value of the Class_Lab_Status entity.
// If the Class_Lab_Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassLabStatusMutation) OldIsOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOpen: %w", err)
	}
	return oldValue.IsOpen, nil
}

// ResetIsOpen resets all changes to the "is_open" field.
func (m *ClassLabStatusMutation) ResetIsOpen() {
	m.is_open = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ClassLabStatusMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ClassLabStatusMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ClassLabStatusMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ClassLabStatusMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ClassLabStatusMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ClassLabStatusMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ClassLabStatusMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ClassLabStatusMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// ClearLab clears the "lab" edge to the Lab entity.
func (m *ClassLabStatusMutation) ClearLab() {
	m.clearedlab = true
}

// LabCleared reports if the "lab" edge to the Lab entity was cleared.
func (m *ClassLabStatusMutation) LabCleared() bool {
	return m.clearedlab
}

// LabIDs returns the "lab" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LabID instead. It exists only for internal usage by the builders.
func (m *ClassLabStatusMutation) LabIDs() (ids []int) {
	if id := m.lab; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLab resets all changes to the "lab" edge.
func (m *ClassLabStatusMutation) ResetLab() {
	m.lab = nil
	m.clearedlab = false
}

// Where appends a list predicates to the ClassLabStatusMutation builder.
func (m *ClassLabStatusMutation) Where(ps ...predicate.Class_Lab_Status) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassLabStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassLabStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class_Lab_Status, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassLabStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassLabStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class_Lab_Status).
func (m *ClassLabStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassLabStatusMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.course != nil {
		fields = append(fields, class_lab_status.FieldCourseID)
	}
	if m.class != nil {
		fields = append(fields, class_lab_status.FieldClassID)
	}
	if m.lab != nil {
		fields = append(fields, class_lab_status.FieldLabID)
	}
	if m.is_open != nil {
		fields = append(fields, class_lab_status.FieldIsOpen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassLabStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class_lab_status.FieldCourseID:
		return m.CourseID()
	case class_lab_status.FieldClassID:
		return m.ClassID()
	case class_lab_status.FieldLabID:
		return m.LabID()
	case class_lab_status.FieldIsOpen:
		return m.IsOpen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassLabStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class_lab_status.FieldCourseID:
		return m.OldCourseID(ctx)
	case class_lab_status.FieldClassID:
		return m.OldClassID(ctx)
	case class_lab_status.FieldLabID:
		return m.OldLabID(ctx)
	case class_lab_status.FieldIsOpen:
		return m.OldIsOpen(ctx)
	}
	return nil, fmt.Errorf("unknown Class_Lab_Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassLabStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class_lab_status.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case class_lab_status.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case class_lab_status.FieldLabID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabID(v)
		return nil
	case class_lab_status.FieldIsOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOpen(v)
		return nil
	}
	return fmt.Errorf("unknown Class_Lab_Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassLabStatusMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassLabStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassLabStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class_Lab_Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassLabStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassLabStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassLabStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class_Lab_Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassLabStatusMutation) ResetField(name string) error {
	switch name {
	case class_lab_status.FieldCourseID:
		m.ResetCourseID()
		return nil
	case class_lab_status.FieldClassID:
		m.ResetClassID()
		return nil
	case class_lab_status.FieldLabID:
		m.ResetLabID()
		return nil
	case class_lab_status.FieldIsOpen:
		m.ResetIsOpen()
		return nil
	}
	return fmt.Errorf("unknown Class_Lab_Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassLabStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, class_lab_status.EdgeCourse)
	}
	if m.class != nil {
		edges = append(edges, class_lab_status.EdgeClass)
	}
	if m.lab != nil {
		edges = append(edges, class_lab_status.EdgeLab)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassLabStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class_lab_status.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case class_lab_status.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case class_lab_status.EdgeLab:
		if id := m.lab; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassLabStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassLabStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassLabStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, class_lab_status.EdgeCourse)
	}
	if m.clearedclass {
		edges = append(edges, class_lab_status.EdgeClass)
	}
	if m.clearedlab {
		edges = append(edges, class_lab_status.EdgeLab)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassLabStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case class_lab_status.EdgeCourse:
		return m.clearedcourse
	case class_lab_status.EdgeClass:
		return m.clearedclass
	case class_lab_status.EdgeLab:
		return m.clearedlab
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassLabStatusMutation) ClearEdge(name string) error {
	switch name {
	case class_lab_status.EdgeCourse:
		m.ClearCourse()
		return nil
	case class_lab_status.EdgeClass:
		m.ClearClass()
		return nil
	case class_lab_status.EdgeLab:
		m.ClearLab()
		return nil
	}
	return fmt.Errorf("unknown Class_Lab_Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassLabStatusMutation) ResetEdge(name string) error {
	switch name {
	case class_lab_status.EdgeCourse:
		m.ResetCourse()
		return nil
	case class_lab_status.EdgeClass:
		m.ResetClass()
		return nil
	case class_lab_status.EdgeLab:
		m.ResetLab()
		return nil
	}
	return fmt.Errorf("unknown Class_Lab_Status edge %s", name)
}

// ClassUserRoleMutation represents an operation that mutates the Class_User_Role nodes in the graph.
type ClassUserRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role          *class_user_role.Role
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	class         *int
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*Class_User_Role, error)
	predicates    []predicate.Class_User_Role
}

var _ ent.Mutation = (*ClassUserRoleMutation)(nil)

// classUserRoleOption allows management of the mutation configuration using functional options.
type classUserRoleOption func(*ClassUserRoleMutation)

// newClassUserRoleMutation creates new mutation for the Class_User_Role entity.
func newClassUserRoleMutation(c config, op Op, opts ...classUserRoleOption) *ClassUserRoleMutation {
	m := &ClassUserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeClassUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClass_User_RoleID sets the ID field of the mutation.
func withClass_User_RoleID(id int) classUserRoleOption {
	return func(m *ClassUserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Class_User_Role
		)
		m.oldValue = func(ctx context.Context) (*Class_User_Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class_User_Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass_User_Role sets the old Class_User_Role of the mutation.
func withClass_User_Role(node *Class_User_Role) classUserRoleOption {
	return func(m *ClassUserRoleMutation) {
		m.oldValue = func(context.Context) (*Class_User_Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassUserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassUserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassUserRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassUserRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class_User_Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ClassUserRoleMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ClassUserRoleMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Class_User_Role entity.
// If the Class_User_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassUserRoleMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ClassUserRoleMutation) ResetUserID() {
	m.user = nil
}

// SetClassID sets the "class_id" field.
func (m *ClassUserRoleMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *ClassUserRoleMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Class_User_Role entity.
// If the Class_User_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassUserRoleMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ResetClassID resets all changes to the "class_id" field.
func (m *ClassUserRoleMutation) ResetClassID() {
	m.class = nil
}

// SetRole sets the "role" field.
func (m *ClassUserRoleMutation) SetRole(cur class_user_role.Role) {
	m.role = &cur
}

// Role returns the value of the "role" field in the mutation.
func (m *ClassUserRoleMutation) Role() (r class_user_role.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Class_User_Role entity.
// If the Class_User_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassUserRoleMutation) OldRole(ctx context.Context) (v class_user_role.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ClassUserRoleMutation) ResetRole() {
	m.role = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ClassUserRoleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ClassUserRoleMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ClassUserRoleMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ClassUserRoleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ClassUserRoleMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ClassUserRoleMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ClassUserRoleMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ClassUserRoleMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the ClassUserRoleMutation builder.
func (m *ClassUserRoleMutation) Where(ps ...predicate.Class_User_Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassUserRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassUserRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class_User_Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassUserRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassUserRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class_User_Role).
func (m *ClassUserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassUserRoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, class_user_role.FieldUserID)
	}
	if m.class != nil {
		fields = append(fields, class_user_role.FieldClassID)
	}
	if m.role != nil {
		fields = append(fields, class_user_role.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassUserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class_user_role.FieldUserID:
		return m.UserID()
	case class_user_role.FieldClassID:
		return m.ClassID()
	case class_user_role.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassUserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class_user_role.FieldUserID:
		return m.OldUserID(ctx)
	case class_user_role.FieldClassID:
		return m.OldClassID(ctx)
	case class_user_role.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown Class_User_Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassUserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class_user_role.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case class_user_role.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case class_user_role.FieldRole:
		v, ok := value.(class_user_role.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown Class_User_Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassUserRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassUserRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassUserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class_User_Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassUserRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassUserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassUserRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class_User_Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassUserRoleMutation) ResetField(name string) error {
	switch name {
	case class_user_role.FieldUserID:
		m.ResetUserID()
		return nil
	case class_user_role.FieldClassID:
		m.ResetClassID()
		return nil
	case class_user_role.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Class_User_Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassUserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, class_user_role.EdgeUser)
	}
	if m.class != nil {
		edges = append(edges, class_user_role.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassUserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class_user_role.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case class_user_role.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassUserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassUserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassUserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, class_user_role.EdgeUser)
	}
	if m.clearedclass {
		edges = append(edges, class_user_role.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassUserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case class_user_role.EdgeUser:
		return m.cleareduser
	case class_user_role.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassUserRoleMutation) ClearEdge(name string) error {
	switch name {
	case class_user_role.EdgeUser:
		m.ClearUser()
		return nil
	case class_user_role.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Class_User_Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassUserRoleMutation) ResetEdge(name string) error {
	switch name {
	case class_user_role.EdgeUser:
		m.ResetUser()
		return nil
	case class_user_role.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Class_User_Role edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	description                *string
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	owner                      *int
	clearedowner               bool
	classes                    map[int]struct{}
	removedclasses             map[int]struct{}
	clearedclasses             bool
	labs                       map[int]struct{}
	removedlabs                map[int]struct{}
	clearedlabs                bool
	topics                     map[int]struct{}
	removedtopics              map[int]struct{}
	clearedtopics              bool
	course_lab_statuses        map[int]struct{}
	removedcourse_lab_statuses map[int]struct{}
	clearedcourse_lab_statuses bool
	done                       bool
	oldValue                   func(context.Context) (*Course, error)
	predicates                 []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner_id" field.
func (m *CourseMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CourseMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CourseMutation) ResetOwnerID() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CourseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[course.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CourseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[course.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, course.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *CourseMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[course.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *CourseMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[course.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, course.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CourseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[course.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CourseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[course.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, course.FieldUpdatedAt)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CourseMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CourseMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CourseMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *CourseMutation) AddClassIDs(ids ...int) {
	if m.classes == nil {
		m.classes = make(map[int]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *CourseMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *CourseMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *CourseMutation) RemoveClassIDs(ids ...int) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *CourseMutation) RemovedClassesIDs() (ids []int) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *CourseMutation) ClassesIDs() (ids []int) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *CourseMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddLabIDs adds the "labs" edge to the Lab entity by ids.
func (m *CourseMutation) AddLabIDs(ids ...int) {
	if m.labs == nil {
		m.labs = make(map[int]struct{})
	}
	for i := range ids {
		m.labs[ids[i]] = struct{}{}
	}
}

// ClearLabs clears the "labs" edge to the Lab entity.
func (m *CourseMutation) ClearLabs() {
	m.clearedlabs = true
}

// LabsCleared reports if the "labs" edge to the Lab entity was cleared.
func (m *CourseMutation) LabsCleared() bool {
	return m.clearedlabs
}

// RemoveLabIDs removes the "labs" edge to the Lab entity by IDs.
func (m *CourseMutation) RemoveLabIDs(ids ...int) {
	if m.removedlabs == nil {
		m.removedlabs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.labs, ids[i])
		m.removedlabs[ids[i]] = struct{}{}
	}
}

// RemovedLabs returns the removed IDs of the "labs" edge to the Lab entity.
func (m *CourseMutation) RemovedLabsIDs() (ids []int) {
	for id := range m.removedlabs {
		ids = append(ids, id)
	}
	return
}

// LabsIDs returns the "labs" edge IDs in the mutation.
func (m *CourseMutation) LabsIDs() (ids []int) {
	for id := range m.labs {
		ids = append(ids, id)
	}
	return
}

// ResetLabs resets all changes to the "labs" edge.
func (m *CourseMutation) ResetLabs() {
	m.labs = nil
	m.clearedlabs = false
	m.removedlabs = nil
}

// AddTopicIDs adds the "topics" edge to the Topic entity by ids.
func (m *CourseMutation) AddTopicIDs(ids ...int) {
	if m.topics == nil {
		m.topics = make(map[int]struct{})
	}
	for i := range ids {
		m.topics[ids[i]] = struct{}{}
	}
}

// ClearTopics clears the "topics" edge to the Topic entity.
func (m *CourseMutation) ClearTopics() {
	m.clearedtopics = true
}

// TopicsCleared reports if the "topics" edge to the Topic entity was cleared.
func (m *CourseMutation) TopicsCleared() bool {
	return m.clearedtopics
}

// RemoveTopicIDs removes the "topics" edge to the Topic entity by IDs.
func (m *CourseMutation) RemoveTopicIDs(ids ...int) {
	if m.removedtopics == nil {
		m.removedtopics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.topics, ids[i])
		m.removedtopics[ids[i]] = struct{}{}
	}
}

// RemovedTopics returns the removed IDs of the "topics" edge to the Topic entity.
func (m *CourseMutation) RemovedTopicsIDs() (ids []int) {
	for id := range m.removedtopics {
		ids = append(ids, id)
	}
	return
}

// TopicsIDs returns the "topics" edge IDs in the mutation.
func (m *CourseMutation) TopicsIDs() (ids []int) {
	for id := range m.topics {
		ids = append(ids, id)
	}
	return
}

// ResetTopics resets all changes to the "topics" edge.
func (m *CourseMutation) ResetTopics() {
	m.topics = nil
	m.clearedtopics = false
	m.removedtopics = nil
}

// AddCourseLabStatusIDs adds the "course_lab_statuses" edge to the Class_Lab_Status entity by ids.
func (m *CourseMutation) AddCourseLabStatusIDs(ids ...int) {
	if m.course_lab_statuses == nil {
		m.course_lab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.course_lab_statuses[ids[i]] = struct{}{}
	}
}

// ClearCourseLabStatuses clears the "course_lab_statuses" edge to the Class_Lab_Status entity.
func (m *CourseMutation) ClearCourseLabStatuses() {
	m.clearedcourse_lab_statuses = true
}

// CourseLabStatusesCleared reports if the "course_lab_statuses" edge to the Class_Lab_Status entity was cleared.
func (m *CourseMutation) CourseLabStatusesCleared() bool {
	return m.clearedcourse_lab_statuses
}

// RemoveCourseLabStatusIDs removes the "course_lab_statuses" edge to the Class_Lab_Status entity by IDs.
func (m *CourseMutation) RemoveCourseLabStatusIDs(ids ...int) {
	if m.removedcourse_lab_statuses == nil {
		m.removedcourse_lab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.course_lab_statuses, ids[i])
		m.removedcourse_lab_statuses[ids[i]] = struct{}{}
	}
}

// RemovedCourseLabStatuses returns the removed IDs of the "course_lab_statuses" edge to the Class_Lab_Status entity.
func (m *CourseMutation) RemovedCourseLabStatusesIDs() (ids []int) {
	for id := range m.removedcourse_lab_statuses {
		ids = append(ids, id)
	}
	return
}

// CourseLabStatusesIDs returns the "course_lab_statuses" edge IDs in the mutation.
func (m *CourseMutation) CourseLabStatusesIDs() (ids []int) {
	for id := range m.course_lab_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseLabStatuses resets all changes to the "course_lab_statuses" edge.
func (m *CourseMutation) ResetCourseLabStatuses() {
	m.course_lab_statuses = nil
	m.clearedcourse_lab_statuses = false
	m.removedcourse_lab_statuses = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.owner != nil {
		fields = append(fields, course.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldOwnerID:
		return m.OwnerID()
	case course.FieldName:
		return m.Name()
	case course.FieldDescription:
		return m.Description()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldDescription) {
		fields = append(fields, course.FieldDescription)
	}
	if m.FieldCleared(course.FieldCreatedAt) {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.FieldCleared(course.FieldUpdatedAt) {
		fields = append(fields, course.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldDescription:
		m.ClearDescription()
		return nil
	case course.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, course.EdgeOwner)
	}
	if m.classes != nil {
		edges = append(edges, course.EdgeClasses)
	}
	if m.labs != nil {
		edges = append(edges, course.EdgeLabs)
	}
	if m.topics != nil {
		edges = append(edges, course.EdgeTopics)
	}
	if m.course_lab_statuses != nil {
		edges = append(edges, course.EdgeCourseLabStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeLabs:
		ids := make([]ent.Value, 0, len(m.labs))
		for id := range m.labs {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.topics))
		for id := range m.topics {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseLabStatuses:
		ids := make([]ent.Value, 0, len(m.course_lab_statuses))
		for id := range m.course_lab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedclasses != nil {
		edges = append(edges, course.EdgeClasses)
	}
	if m.removedlabs != nil {
		edges = append(edges, course.EdgeLabs)
	}
	if m.removedtopics != nil {
		edges = append(edges, course.EdgeTopics)
	}
	if m.removedcourse_lab_statuses != nil {
		edges = append(edges, course.EdgeCourseLabStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeLabs:
		ids := make([]ent.Value, 0, len(m.removedlabs))
		for id := range m.removedlabs {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.removedtopics))
		for id := range m.removedtopics {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeCourseLabStatuses:
		ids := make([]ent.Value, 0, len(m.removedcourse_lab_statuses))
		for id := range m.removedcourse_lab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, course.EdgeOwner)
	}
	if m.clearedclasses {
		edges = append(edges, course.EdgeClasses)
	}
	if m.clearedlabs {
		edges = append(edges, course.EdgeLabs)
	}
	if m.clearedtopics {
		edges = append(edges, course.EdgeTopics)
	}
	if m.clearedcourse_lab_statuses {
		edges = append(edges, course.EdgeCourseLabStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeOwner:
		return m.clearedowner
	case course.EdgeClasses:
		return m.clearedclasses
	case course.EdgeLabs:
		return m.clearedlabs
	case course.EdgeTopics:
		return m.clearedtopics
	case course.EdgeCourseLabStatuses:
		return m.clearedcourse_lab_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ResetOwner()
		return nil
	case course.EdgeClasses:
		m.ResetClasses()
		return nil
	case course.EdgeLabs:
		m.ResetLabs()
		return nil
	case course.EdgeTopics:
		m.ResetTopics()
		return nil
	case course.EdgeCourseLabStatuses:
		m.ResetCourseLabStatuses()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// LabMutation represents an operation that mutates the Lab nodes in the graph.
type LabMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	course              *int
	clearedcourse       bool
	lab_problems        map[int]struct{}
	removedlab_problems map[int]struct{}
	clearedlab_problems bool
	lab_statuses        map[int]struct{}
	removedlab_statuses map[int]struct{}
	clearedlab_statuses bool
	done                bool
	oldValue            func(context.Context) (*Lab, error)
	predicates          []predicate.Lab
}

var _ ent.Mutation = (*LabMutation)(nil)

// labOption allows management of the mutation configuration using functional options.
type labOption func(*LabMutation)

// newLabMutation creates new mutation for the Lab entity.
func newLabMutation(c config, op Op, opts ...labOption) *LabMutation {
	m := &LabMutation{
		config:        c,
		op:            op,
		typ:           TypeLab,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLabID sets the ID field of the mutation.
func withLabID(id int) labOption {
	return func(m *LabMutation) {
		var (
			err   error
			once  sync.Once
			value *Lab
		)
		m.oldValue = func(ctx context.Context) (*Lab, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lab.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLab sets the old Lab of the mutation.
func withLab(node *Lab) labOption {
	return func(m *LabMutation) {
		m.oldValue = func(context.Context) (*Lab, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lab.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCourseID sets the "course_id" field.
func (m *LabMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *LabMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Lab entity.
// If the Lab object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *LabMutation) ResetCourseID() {
	m.course = nil
}

// SetName sets the "name" field.
func (m *LabMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LabMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lab entity.
// If the Lab object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LabMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LabMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LabMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lab entity.
// If the Lab object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LabMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LabMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LabMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lab entity.
// If the Lab object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LabMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *LabMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *LabMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *LabMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *LabMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddLabProblemIDs adds the "lab_problems" edge to the Lab_Problem entity by ids.
func (m *LabMutation) AddLabProblemIDs(ids ...int) {
	if m.lab_problems == nil {
		m.lab_problems = make(map[int]struct{})
	}
	for i := range ids {
		m.lab_problems[ids[i]] = struct{}{}
	}
}

// ClearLabProblems clears the "lab_problems" edge to the Lab_Problem entity.
func (m *LabMutation) ClearLabProblems() {
	m.clearedlab_problems = true
}

// LabProblemsCleared reports if the "lab_problems" edge to the Lab_Problem entity was cleared.
func (m *LabMutation) LabProblemsCleared() bool {
	return m.clearedlab_problems
}

// RemoveLabProblemIDs removes the "lab_problems" edge to the Lab_Problem entity by IDs.
func (m *LabMutation) RemoveLabProblemIDs(ids ...int) {
	if m.removedlab_problems == nil {
		m.removedlab_problems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lab_problems, ids[i])
		m.removedlab_problems[ids[i]] = struct{}{}
	}
}

// RemovedLabProblems returns the removed IDs of the "lab_problems" edge to the Lab_Problem entity.
func (m *LabMutation) RemovedLabProblemsIDs() (ids []int) {
	for id := range m.removedlab_problems {
		ids = append(ids, id)
	}
	return
}

// LabProblemsIDs returns the "lab_problems" edge IDs in the mutation.
func (m *LabMutation) LabProblemsIDs() (ids []int) {
	for id := range m.lab_problems {
		ids = append(ids, id)
	}
	return
}

// ResetLabProblems resets all changes to the "lab_problems" edge.
func (m *LabMutation) ResetLabProblems() {
	m.lab_problems = nil
	m.clearedlab_problems = false
	m.removedlab_problems = nil
}

// AddLabStatusIDs adds the "lab_statuses" edge to the Class_Lab_Status entity by ids.
func (m *LabMutation) AddLabStatusIDs(ids ...int) {
	if m.lab_statuses == nil {
		m.lab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.lab_statuses[ids[i]] = struct{}{}
	}
}

// ClearLabStatuses clears the "lab_statuses" edge to the Class_Lab_Status entity.
func (m *LabMutation) ClearLabStatuses() {
	m.clearedlab_statuses = true
}

// LabStatusesCleared reports if the "lab_statuses" edge to the Class_Lab_Status entity was cleared.
func (m *LabMutation) LabStatusesCleared() bool {
	return m.clearedlab_statuses
}

// RemoveLabStatusIDs removes the "lab_statuses" edge to the Class_Lab_Status entity by IDs.
func (m *LabMutation) RemoveLabStatusIDs(ids ...int) {
	if m.removedlab_statuses == nil {
		m.removedlab_statuses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lab_statuses, ids[i])
		m.removedlab_statuses[ids[i]] = struct{}{}
	}
}

// RemovedLabStatuses returns the removed IDs of the "lab_statuses" edge to the Class_Lab_Status entity.
func (m *LabMutation) RemovedLabStatusesIDs() (ids []int) {
	for id := range m.removedlab_statuses {
		ids = append(ids, id)
	}
	return
}

// LabStatusesIDs returns the "lab_statuses" edge IDs in the mutation.
func (m *LabMutation) LabStatusesIDs() (ids []int) {
	for id := range m.lab_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetLabStatuses resets all changes to the "lab_statuses" edge.
func (m *LabMutation) ResetLabStatuses() {
	m.lab_statuses = nil
	m.clearedlab_statuses = false
	m.removedlab_statuses = nil
}

// Where appends a list predicates to the LabMutation builder.
func (m *LabMutation) Where(ps ...predicate.Lab) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LabMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LabMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lab, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LabMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LabMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lab).
func (m *LabMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.course != nil {
		fields = append(fields, lab.FieldCourseID)
	}
	if m.name != nil {
		fields = append(fields, lab.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, lab.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lab.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lab.FieldCourseID:
		return m.CourseID()
	case lab.FieldName:
		return m.Name()
	case lab.FieldCreatedAt:
		return m.CreatedAt()
	case lab.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lab.FieldCourseID:
		return m.OldCourseID(ctx)
	case lab.FieldName:
		return m.OldName(ctx)
	case lab.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lab.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lab field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lab.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case lab.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lab.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lab.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lab field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lab numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Lab nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabMutation) ResetField(name string) error {
	switch name {
	case lab.FieldCourseID:
		m.ResetCourseID()
		return nil
	case lab.FieldName:
		m.ResetName()
		return nil
	case lab.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lab.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lab field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, lab.EdgeCourse)
	}
	if m.lab_problems != nil {
		edges = append(edges, lab.EdgeLabProblems)
	}
	if m.lab_statuses != nil {
		edges = append(edges, lab.EdgeLabStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lab.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case lab.EdgeLabProblems:
		ids := make([]ent.Value, 0, len(m.lab_problems))
		for id := range m.lab_problems {
			ids = append(ids, id)
		}
		return ids
	case lab.EdgeLabStatuses:
		ids := make([]ent.Value, 0, len(m.lab_statuses))
		for id := range m.lab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlab_problems != nil {
		edges = append(edges, lab.EdgeLabProblems)
	}
	if m.removedlab_statuses != nil {
		edges = append(edges, lab.EdgeLabStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lab.EdgeLabProblems:
		ids := make([]ent.Value, 0, len(m.removedlab_problems))
		for id := range m.removedlab_problems {
			ids = append(ids, id)
		}
		return ids
	case lab.EdgeLabStatuses:
		ids := make([]ent.Value, 0, len(m.removedlab_statuses))
		for id := range m.removedlab_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, lab.EdgeCourse)
	}
	if m.clearedlab_problems {
		edges = append(edges, lab.EdgeLabProblems)
	}
	if m.clearedlab_statuses {
		edges = append(edges, lab.EdgeLabStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabMutation) EdgeCleared(name string) bool {
	switch name {
	case lab.EdgeCourse:
		return m.clearedcourse
	case lab.EdgeLabProblems:
		return m.clearedlab_problems
	case lab.EdgeLabStatuses:
		return m.clearedlab_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabMutation) ClearEdge(name string) error {
	switch name {
	case lab.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Lab unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabMutation) ResetEdge(name string) error {
	switch name {
	case lab.EdgeCourse:
		m.ResetCourse()
		return nil
	case lab.EdgeLabProblems:
		m.ResetLabProblems()
		return nil
	case lab.EdgeLabStatuses:
		m.ResetLabStatuses()
		return nil
	}
	return fmt.Errorf("unknown Lab edge %s", name)
}

// LabProblemMutation represents an operation that mutates the Lab_Problem nodes in the graph.
type LabProblemMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	prompt           *string
	full_score       *float64
	addfull_score    *float64
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	lab              *int
	clearedlab       bool
	testcases        map[int]struct{}
	removedtestcases map[int]struct{}
	clearedtestcases bool
	done             bool
	oldValue         func(context.Context) (*Lab_Problem, error)
	predicates       []predicate.Lab_Problem
}

var _ ent.Mutation = (*LabProblemMutation)(nil)

// labProblemOption allows management of the mutation configuration using functional options.
type labProblemOption func(*LabProblemMutation)

// newLabProblemMutation creates new mutation for the Lab_Problem entity.
func newLabProblemMutation(c config, op Op, opts ...labProblemOption) *LabProblemMutation {
	m := &LabProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeLabProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLab_ProblemID sets the ID field of the mutation.
func withLab_ProblemID(id int) labProblemOption {
	return func(m *LabProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *Lab_Problem
		)
		m.oldValue = func(ctx context.Context) (*Lab_Problem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lab_Problem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLab_Problem sets the old Lab_Problem of the mutation.
func withLab_Problem(node *Lab_Problem) labProblemOption {
	return func(m *LabProblemMutation) {
		m.oldValue = func(context.Context) (*Lab_Problem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabProblemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabProblemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lab_Problem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabID sets the "lab_id" field.
func (m *LabProblemMutation) SetLabID(i int) {
	m.lab = &i
}

// LabID returns the value of the "lab_id" field in the mutation.
func (m *LabProblemMutation) LabID() (r int, exists bool) {
	v := m.lab
	if v == nil {
		return
	}
	return *v, true
}

// OldLabID returns the old "lab_id" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldLabID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabID: %w", err)
	}
	return oldValue.LabID, nil
}

// ResetLabID resets all changes to the "lab_id" field.
func (m *LabProblemMutation) ResetLabID() {
	m.lab = nil
}

// SetName sets the "name" field.
func (m *LabProblemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LabProblemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LabProblemMutation) ResetName() {
	m.name = nil
}

// SetPrompt sets the "prompt" field.
func (m *LabProblemMutation) SetPrompt(s string) {
	m.prompt = &s
}

// Prompt returns the value of the "prompt" field in the mutation.
func (m *LabProblemMutation) Prompt() (r string, exists bool) {
	v := m.prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldPrompt returns the old "prompt" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldPrompt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrompt: %w", err)
	}
	return oldValue.Prompt, nil
}

// ResetPrompt resets all changes to the "prompt" field.
func (m *LabProblemMutation) ResetPrompt() {
	m.prompt = nil
}

// SetFullScore sets the "full_score" field.
func (m *LabProblemMutation) SetFullScore(f float64) {
	m.full_score = &f
	m.addfull_score = nil
}

// FullScore returns the value of the "full_score" field in the mutation.
func (m *LabProblemMutation) FullScore() (r float64, exists bool) {
	v := m.full_score
	if v == nil {
		return
	}
	return *v, true
}

// OldFullScore returns the old "full_score" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldFullScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullScore: %w", err)
	}
	return oldValue.FullScore, nil
}

// AddFullScore adds f to the "full_score" field.
func (m *LabProblemMutation) AddFullScore(f float64) {
	if m.addfull_score != nil {
		*m.addfull_score += f
	} else {
		m.addfull_score = &f
	}
}

// AddedFullScore returns the value that was added to the "full_score" field in this mutation.
func (m *LabProblemMutation) AddedFullScore() (r float64, exists bool) {
	v := m.addfull_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearFullScore clears the value of the "full_score" field.
func (m *LabProblemMutation) ClearFullScore() {
	m.full_score = nil
	m.addfull_score = nil
	m.clearedFields[lab_problem.FieldFullScore] = struct{}{}
}

// FullScoreCleared returns if the "full_score" field was cleared in this mutation.
func (m *LabProblemMutation) FullScoreCleared() bool {
	_, ok := m.clearedFields[lab_problem.FieldFullScore]
	return ok
}

// ResetFullScore resets all changes to the "full_score" field.
func (m *LabProblemMutation) ResetFullScore() {
	m.full_score = nil
	m.addfull_score = nil
	delete(m.clearedFields, lab_problem.FieldFullScore)
}

// SetCreatedAt sets the "created_at" field.
func (m *LabProblemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LabProblemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LabProblemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LabProblemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LabProblemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lab_Problem entity.
// If the Lab_Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LabProblemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearLab clears the "lab" edge to the Lab entity.
func (m *LabProblemMutation) ClearLab() {
	m.clearedlab = true
}

// LabCleared reports if the "lab" edge to the Lab entity was cleared.
func (m *LabProblemMutation) LabCleared() bool {
	return m.clearedlab
}

// LabIDs returns the "lab" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LabID instead. It exists only for internal usage by the builders.
func (m *LabProblemMutation) LabIDs() (ids []int) {
	if id := m.lab; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLab resets all changes to the "lab" edge.
func (m *LabProblemMutation) ResetLab() {
	m.lab = nil
	m.clearedlab = false
}

// AddTestcaseIDs adds the "testcases" edge to the Testcase entity by ids.
func (m *LabProblemMutation) AddTestcaseIDs(ids ...int) {
	if m.testcases == nil {
		m.testcases = make(map[int]struct{})
	}
	for i := range ids {
		m.testcases[ids[i]] = struct{}{}
	}
}

// ClearTestcases clears the "testcases" edge to the Testcase entity.
func (m *LabProblemMutation) ClearTestcases() {
	m.clearedtestcases = true
}

// TestcasesCleared reports if the "testcases" edge to the Testcase entity was cleared.
func (m *LabProblemMutation) TestcasesCleared() bool {
	return m.clearedtestcases
}

// RemoveTestcaseIDs removes the "testcases" edge to the Testcase entity by IDs.
func (m *LabProblemMutation) RemoveTestcaseIDs(ids ...int) {
	if m.removedtestcases == nil {
		m.removedtestcases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.testcases, ids[i])
		m.removedtestcases[ids[i]] = struct{}{}
	}
}

// RemovedTestcases returns the removed IDs of the "testcases" edge to the Testcase entity.
func (m *LabProblemMutation) RemovedTestcasesIDs() (ids []int) {
	for id := range m.removedtestcases {
		ids = append(ids, id)
	}
	return
}

// TestcasesIDs returns the "testcases" edge IDs in the mutation.
func (m *LabProblemMutation) TestcasesIDs() (ids []int) {
	for id := range m.testcases {
		ids = append(ids, id)
	}
	return
}

// ResetTestcases resets all changes to the "testcases" edge.
func (m *LabProblemMutation) ResetTestcases() {
	m.testcases = nil
	m.clearedtestcases = false
	m.removedtestcases = nil
}

// Where appends a list predicates to the LabProblemMutation builder.
func (m *LabProblemMutation) Where(ps ...predicate.Lab_Problem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LabProblemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LabProblemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lab_Problem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LabProblemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LabProblemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lab_Problem).
func (m *LabProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabProblemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.lab != nil {
		fields = append(fields, lab_problem.FieldLabID)
	}
	if m.name != nil {
		fields = append(fields, lab_problem.FieldName)
	}
	if m.prompt != nil {
		fields = append(fields, lab_problem.FieldPrompt)
	}
	if m.full_score != nil {
		fields = append(fields, lab_problem.FieldFullScore)
	}
	if m.created_at != nil {
		fields = append(fields, lab_problem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lab_problem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lab_problem.FieldLabID:
		return m.LabID()
	case lab_problem.FieldName:
		return m.Name()
	case lab_problem.FieldPrompt:
		return m.Prompt()
	case lab_problem.FieldFullScore:
		return m.FullScore()
	case lab_problem.FieldCreatedAt:
		return m.CreatedAt()
	case lab_problem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lab_problem.FieldLabID:
		return m.OldLabID(ctx)
	case lab_problem.FieldName:
		return m.OldName(ctx)
	case lab_problem.FieldPrompt:
		return m.OldPrompt(ctx)
	case lab_problem.FieldFullScore:
		return m.OldFullScore(ctx)
	case lab_problem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lab_problem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lab_Problem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lab_problem.FieldLabID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabID(v)
		return nil
	case lab_problem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lab_problem.FieldPrompt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrompt(v)
		return nil
	case lab_problem.FieldFullScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullScore(v)
		return nil
	case lab_problem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lab_problem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabProblemMutation) AddedFields() []string {
	var fields []string
	if m.addfull_score != nil {
		fields = append(fields, lab_problem.FieldFullScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabProblemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lab_problem.FieldFullScore:
		return m.AddedFullScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lab_problem.FieldFullScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFullScore(v)
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabProblemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lab_problem.FieldFullScore) {
		fields = append(fields, lab_problem.FieldFullScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabProblemMutation) ClearField(name string) error {
	switch name {
	case lab_problem.FieldFullScore:
		m.ClearFullScore()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabProblemMutation) ResetField(name string) error {
	switch name {
	case lab_problem.FieldLabID:
		m.ResetLabID()
		return nil
	case lab_problem.FieldName:
		m.ResetName()
		return nil
	case lab_problem.FieldPrompt:
		m.ResetPrompt()
		return nil
	case lab_problem.FieldFullScore:
		m.ResetFullScore()
		return nil
	case lab_problem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lab_problem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lab != nil {
		edges = append(edges, lab_problem.EdgeLab)
	}
	if m.testcases != nil {
		edges = append(edges, lab_problem.EdgeTestcases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lab_problem.EdgeLab:
		if id := m.lab; id != nil {
			return []ent.Value{*id}
		}
	case lab_problem.EdgeTestcases:
		ids := make([]ent.Value, 0, len(m.testcases))
		for id := range m.testcases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtestcases != nil {
		edges = append(edges, lab_problem.EdgeTestcases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabProblemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lab_problem.EdgeTestcases:
		ids := make([]ent.Value, 0, len(m.removedtestcases))
		for id := range m.removedtestcases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlab {
		edges = append(edges, lab_problem.EdgeLab)
	}
	if m.clearedtestcases {
		edges = append(edges, lab_problem.EdgeTestcases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case lab_problem.EdgeLab:
		return m.clearedlab
	case lab_problem.EdgeTestcases:
		return m.clearedtestcases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabProblemMutation) ClearEdge(name string) error {
	switch name {
	case lab_problem.EdgeLab:
		m.ClearLab()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabProblemMutation) ResetEdge(name string) error {
	switch name {
	case lab_problem.EdgeLab:
		m.ResetLab()
		return nil
	case lab_problem.EdgeTestcases:
		m.ResetTestcases()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem edge %s", name)
}

// LabProblemSubmissionMutation represents an operation that mutates the Lab_Problem_Submission nodes in the graph.
type LabProblemSubmissionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	lab_problem_id              *int
	addlab_problem_id           *int
	code                        *string
	score                       *float64
	addscore                    *float64
	feedback                    *string
	instructor_score            *float64
	addinstructor_score         *float64
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	owner                       *int
	clearedowner                bool
	testcase_submissions        map[int]struct{}
	removedtestcase_submissions map[int]struct{}
	clearedtestcase_submissions bool
	done                        bool
	oldValue                    func(context.Context) (*Lab_Problem_Submission, error)
	predicates                  []predicate.Lab_Problem_Submission
}

var _ ent.Mutation = (*LabProblemSubmissionMutation)(nil)

// labProblemSubmissionOption allows management of the mutation configuration using functional options.
type labProblemSubmissionOption func(*LabProblemSubmissionMutation)

// newLabProblemSubmissionMutation creates new mutation for the Lab_Problem_Submission entity.
func newLabProblemSubmissionMutation(c config, op Op, opts ...labProblemSubmissionOption) *LabProblemSubmissionMutation {
	m := &LabProblemSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeLabProblemSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLab_Problem_SubmissionID sets the ID field of the mutation.
func withLab_Problem_SubmissionID(id int) labProblemSubmissionOption {
	return func(m *LabProblemSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Lab_Problem_Submission
		)
		m.oldValue = func(ctx context.Context) (*Lab_Problem_Submission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lab_Problem_Submission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLab_Problem_Submission sets the old Lab_Problem_Submission of the mutation.
func withLab_Problem_Submission(node *Lab_Problem_Submission) labProblemSubmissionOption {
	return func(m *LabProblemSubmissionMutation) {
		m.oldValue = func(context.Context) (*Lab_Problem_Submission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LabProblemSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LabProblemSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LabProblemSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LabProblemSubmissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lab_Problem_Submission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner_id" field.
func (m *LabProblemSubmissionMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *LabProblemSubmissionMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *LabProblemSubmissionMutation) ResetOwnerID() {
	m.owner = nil
}

// SetLabProblemID sets the "lab_problem_id" field.
func (m *LabProblemSubmissionMutation) SetLabProblemID(i int) {
	m.lab_problem_id = &i
	m.addlab_problem_id = nil
}

// LabProblemID returns the value of the "lab_problem_id" field in the mutation.
func (m *LabProblemSubmissionMutation) LabProblemID() (r int, exists bool) {
	v := m.lab_problem_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLabProblemID returns the old "lab_problem_id" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldLabProblemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabProblemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabProblemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabProblemID: %w", err)
	}
	return oldValue.LabProblemID, nil
}

// AddLabProblemID adds i to the "lab_problem_id" field.
func (m *LabProblemSubmissionMutation) AddLabProblemID(i int) {
	if m.addlab_problem_id != nil {
		*m.addlab_problem_id += i
	} else {
		m.addlab_problem_id = &i
	}
}

// AddedLabProblemID returns the value that was added to the "lab_problem_id" field in this mutation.
func (m *LabProblemSubmissionMutation) AddedLabProblemID() (r int, exists bool) {
	v := m.addlab_problem_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLabProblemID resets all changes to the "lab_problem_id" field.
func (m *LabProblemSubmissionMutation) ResetLabProblemID() {
	m.lab_problem_id = nil
	m.addlab_problem_id = nil
}

// SetCode sets the "code" field.
func (m *LabProblemSubmissionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LabProblemSubmissionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *LabProblemSubmissionMutation) ResetCode() {
	m.code = nil
}

// SetScore sets the "score" field.
func (m *LabProblemSubmissionMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *LabProblemSubmissionMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *LabProblemSubmissionMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *LabProblemSubmissionMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *LabProblemSubmissionMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetFeedback sets the "feedback" field.
func (m *LabProblemSubmissionMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *LabProblemSubmissionMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ClearFeedback clears the value of the "feedback" field.
func (m *LabProblemSubmissionMutation) ClearFeedback() {
	m.feedback = nil
	m.clearedFields[lab_problem_submission.FieldFeedback] = struct{}{}
}

// FeedbackCleared returns if the "feedback" field was cleared in this mutation.
func (m *LabProblemSubmissionMutation) FeedbackCleared() bool {
	_, ok := m.clearedFields[lab_problem_submission.FieldFeedback]
	return ok
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *LabProblemSubmissionMutation) ResetFeedback() {
	m.feedback = nil
	delete(m.clearedFields, lab_problem_submission.FieldFeedback)
}

// SetInstructorScore sets the "instructor_score" field.
func (m *LabProblemSubmissionMutation) SetInstructorScore(f float64) {
	m.instructor_score = &f
	m.addinstructor_score = nil
}

// InstructorScore returns the value of the "instructor_score" field in the mutation.
func (m *LabProblemSubmissionMutation) InstructorScore() (r float64, exists bool) {
	v := m.instructor_score
	if v == nil {
		return
	}
	return *v, true
}

// OldInstructorScore returns the old "instructor_score" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldInstructorScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstructorScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstructorScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstructorScore: %w", err)
	}
	return oldValue.InstructorScore, nil
}

// AddInstructorScore adds f to the "instructor_score" field.
func (m *LabProblemSubmissionMutation) AddInstructorScore(f float64) {
	if m.addinstructor_score != nil {
		*m.addinstructor_score += f
	} else {
		m.addinstructor_score = &f
	}
}

// AddedInstructorScore returns the value that was added to the "instructor_score" field in this mutation.
func (m *LabProblemSubmissionMutation) AddedInstructorScore() (r float64, exists bool) {
	v := m.addinstructor_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetInstructorScore resets all changes to the "instructor_score" field.
func (m *LabProblemSubmissionMutation) ResetInstructorScore() {
	m.instructor_score = nil
	m.addinstructor_score = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LabProblemSubmissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LabProblemSubmissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LabProblemSubmissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LabProblemSubmissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LabProblemSubmissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lab_Problem_Submission entity.
// If the Lab_Problem_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LabProblemSubmissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LabProblemSubmissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *LabProblemSubmissionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *LabProblemSubmissionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *LabProblemSubmissionMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *LabProblemSubmissionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddTestcaseSubmissionIDs adds the "testcase_submissions" edge to the Testcase_Submission entity by ids.
func (m *LabProblemSubmissionMutation) AddTestcaseSubmissionIDs(ids ...int) {
	if m.testcase_submissions == nil {
		m.testcase_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.testcase_submissions[ids[i]] = struct{}{}
	}
}

// ClearTestcaseSubmissions clears the "testcase_submissions" edge to the Testcase_Submission entity.
func (m *LabProblemSubmissionMutation) ClearTestcaseSubmissions() {
	m.clearedtestcase_submissions = true
}

// TestcaseSubmissionsCleared reports if the "testcase_submissions" edge to the Testcase_Submission entity was cleared.
func (m *LabProblemSubmissionMutation) TestcaseSubmissionsCleared() bool {
	return m.clearedtestcase_submissions
}

// RemoveTestcaseSubmissionIDs removes the "testcase_submissions" edge to the Testcase_Submission entity by IDs.
func (m *LabProblemSubmissionMutation) RemoveTestcaseSubmissionIDs(ids ...int) {
	if m.removedtestcase_submissions == nil {
		m.removedtestcase_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.testcase_submissions, ids[i])
		m.removedtestcase_submissions[ids[i]] = struct{}{}
	}
}

// RemovedTestcaseSubmissions returns the removed IDs of the "testcase_submissions" edge to the Testcase_Submission entity.
func (m *LabProblemSubmissionMutation) RemovedTestcaseSubmissionsIDs() (ids []int) {
	for id := range m.removedtestcase_submissions {
		ids = append(ids, id)
	}
	return
}

// TestcaseSubmissionsIDs returns the "testcase_submissions" edge IDs in the mutation.
func (m *LabProblemSubmissionMutation) TestcaseSubmissionsIDs() (ids []int) {
	for id := range m.testcase_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetTestcaseSubmissions resets all changes to the "testcase_submissions" edge.
func (m *LabProblemSubmissionMutation) ResetTestcaseSubmissions() {
	m.testcase_submissions = nil
	m.clearedtestcase_submissions = false
	m.removedtestcase_submissions = nil
}

// Where appends a list predicates to the LabProblemSubmissionMutation builder.
func (m *LabProblemSubmissionMutation) Where(ps ...predicate.Lab_Problem_Submission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LabProblemSubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LabProblemSubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lab_Problem_Submission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LabProblemSubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LabProblemSubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lab_Problem_Submission).
func (m *LabProblemSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LabProblemSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.owner != nil {
		fields = append(fields, lab_problem_submission.FieldOwnerID)
	}
	if m.lab_problem_id != nil {
		fields = append(fields, lab_problem_submission.FieldLabProblemID)
	}
	if m.code != nil {
		fields = append(fields, lab_problem_submission.FieldCode)
	}
	if m.score != nil {
		fields = append(fields, lab_problem_submission.FieldScore)
	}
	if m.feedback != nil {
		fields = append(fields, lab_problem_submission.FieldFeedback)
	}
	if m.instructor_score != nil {
		fields = append(fields, lab_problem_submission.FieldInstructorScore)
	}
	if m.created_at != nil {
		fields = append(fields, lab_problem_submission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lab_problem_submission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LabProblemSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lab_problem_submission.FieldOwnerID:
		return m.OwnerID()
	case lab_problem_submission.FieldLabProblemID:
		return m.LabProblemID()
	case lab_problem_submission.FieldCode:
		return m.Code()
	case lab_problem_submission.FieldScore:
		return m.Score()
	case lab_problem_submission.FieldFeedback:
		return m.Feedback()
	case lab_problem_submission.FieldInstructorScore:
		return m.InstructorScore()
	case lab_problem_submission.FieldCreatedAt:
		return m.CreatedAt()
	case lab_problem_submission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LabProblemSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lab_problem_submission.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case lab_problem_submission.FieldLabProblemID:
		return m.OldLabProblemID(ctx)
	case lab_problem_submission.FieldCode:
		return m.OldCode(ctx)
	case lab_problem_submission.FieldScore:
		return m.OldScore(ctx)
	case lab_problem_submission.FieldFeedback:
		return m.OldFeedback(ctx)
	case lab_problem_submission.FieldInstructorScore:
		return m.OldInstructorScore(ctx)
	case lab_problem_submission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lab_problem_submission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lab_Problem_Submission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabProblemSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lab_problem_submission.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case lab_problem_submission.FieldLabProblemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabProblemID(v)
		return nil
	case lab_problem_submission.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case lab_problem_submission.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case lab_problem_submission.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case lab_problem_submission.FieldInstructorScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstructorScore(v)
		return nil
	case lab_problem_submission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lab_problem_submission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LabProblemSubmissionMutation) AddedFields() []string {
	var fields []string
	if m.addlab_problem_id != nil {
		fields = append(fields, lab_problem_submission.FieldLabProblemID)
	}
	if m.addscore != nil {
		fields = append(fields, lab_problem_submission.FieldScore)
	}
	if m.addinstructor_score != nil {
		fields = append(fields, lab_problem_submission.FieldInstructorScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LabProblemSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lab_problem_submission.FieldLabProblemID:
		return m.AddedLabProblemID()
	case lab_problem_submission.FieldScore:
		return m.AddedScore()
	case lab_problem_submission.FieldInstructorScore:
		return m.AddedInstructorScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LabProblemSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lab_problem_submission.FieldLabProblemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLabProblemID(v)
		return nil
	case lab_problem_submission.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case lab_problem_submission.FieldInstructorScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstructorScore(v)
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LabProblemSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lab_problem_submission.FieldFeedback) {
		fields = append(fields, lab_problem_submission.FieldFeedback)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LabProblemSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LabProblemSubmissionMutation) ClearField(name string) error {
	switch name {
	case lab_problem_submission.FieldFeedback:
		m.ClearFeedback()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LabProblemSubmissionMutation) ResetField(name string) error {
	switch name {
	case lab_problem_submission.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case lab_problem_submission.FieldLabProblemID:
		m.ResetLabProblemID()
		return nil
	case lab_problem_submission.FieldCode:
		m.ResetCode()
		return nil
	case lab_problem_submission.FieldScore:
		m.ResetScore()
		return nil
	case lab_problem_submission.FieldFeedback:
		m.ResetFeedback()
		return nil
	case lab_problem_submission.FieldInstructorScore:
		m.ResetInstructorScore()
		return nil
	case lab_problem_submission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lab_problem_submission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LabProblemSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, lab_problem_submission.EdgeOwner)
	}
	if m.testcase_submissions != nil {
		edges = append(edges, lab_problem_submission.EdgeTestcaseSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LabProblemSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lab_problem_submission.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case lab_problem_submission.EdgeTestcaseSubmissions:
		ids := make([]ent.Value, 0, len(m.testcase_submissions))
		for id := range m.testcase_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LabProblemSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtestcase_submissions != nil {
		edges = append(edges, lab_problem_submission.EdgeTestcaseSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LabProblemSubmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lab_problem_submission.EdgeTestcaseSubmissions:
		ids := make([]ent.Value, 0, len(m.removedtestcase_submissions))
		for id := range m.removedtestcase_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LabProblemSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, lab_problem_submission.EdgeOwner)
	}
	if m.clearedtestcase_submissions {
		edges = append(edges, lab_problem_submission.EdgeTestcaseSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LabProblemSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case lab_problem_submission.EdgeOwner:
		return m.clearedowner
	case lab_problem_submission.EdgeTestcaseSubmissions:
		return m.clearedtestcase_submissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LabProblemSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case lab_problem_submission.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LabProblemSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case lab_problem_submission.EdgeOwner:
		m.ResetOwner()
		return nil
	case lab_problem_submission.EdgeTestcaseSubmissions:
		m.ResetTestcaseSubmissions()
		return nil
	}
	return fmt.Errorf("unknown Lab_Problem_Submission edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	class         *int
	clearedclass  bool
	author        *int
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*Post, error)
	predicates    []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassID sets the "class_id" field.
func (m *PostMutation) SetClassID(i int) {
	m.class = &i
}

// ClassID returns the value of the "class_id" field in the mutation.
func (m *PostMutation) ClassID() (r int, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClassID returns the old "class_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldClassID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassID: %w", err)
	}
	return oldValue.ClassID, nil
}

// ResetClassID resets all changes to the "class_id" field.
func (m *PostMutation) ResetClassID() {
	m.class = nil
}

// SetAuthorID sets the "author_id" field.
func (m *PostMutation) SetAuthorID(i int) {
	m.author = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *PostMutation) AuthorID() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *PostMutation) ResetAuthorID() {
	m.author = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearClass clears the "class" edge to the Class entity.
func (m *PostMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *PostMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *PostMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *PostMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.class != nil {
		fields = append(fields, post.FieldClassID)
	}
	if m.author != nil {
		fields = append(fields, post.FieldAuthorID)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldClassID:
		return m.ClassID()
	case post.FieldAuthorID:
		return m.AuthorID()
	case post.FieldContent:
		return m.Content()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldClassID:
		return m.OldClassID(ctx)
	case post.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldClassID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassID(v)
		return nil
	case post.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldClassID:
		m.ResetClassID()
		return nil
	case post.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, post.EdgeClass)
	}
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, post.EdgeClass)
	}
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeClass:
		return m.clearedclass
	case post.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeClass:
		m.ClearClass()
		return nil
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeClass:
		m.ResetClass()
		return nil
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// TestcaseMutation represents an operation that mutates the Testcase nodes in the graph.
type TestcaseMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	input                       *string
	output                      *string
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	lab_problem                 *int
	clearedlab_problem          bool
	testcase_submissions        map[int]struct{}
	removedtestcase_submissions map[int]struct{}
	clearedtestcase_submissions bool
	done                        bool
	oldValue                    func(context.Context) (*Testcase, error)
	predicates                  []predicate.Testcase
}

var _ ent.Mutation = (*TestcaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestcaseMutation)

// newTestcaseMutation creates new mutation for the Testcase entity.
func newTestcaseMutation(c config, op Op, opts ...testcaseOption) *TestcaseMutation {
	m := &TestcaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestcase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestcaseID sets the ID field of the mutation.
func withTestcaseID(id int) testcaseOption {
	return func(m *TestcaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Testcase
		)
		m.oldValue = func(ctx context.Context) (*Testcase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Testcase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestcase sets the old Testcase of the mutation.
func withTestcase(node *Testcase) testcaseOption {
	return func(m *TestcaseMutation) {
		m.oldValue = func(context.Context) (*Testcase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestcaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestcaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestcaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestcaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Testcase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabProblemID sets the "lab_problem_id" field.
func (m *TestcaseMutation) SetLabProblemID(i int) {
	m.lab_problem = &i
}

// LabProblemID returns the value of the "lab_problem_id" field in the mutation.
func (m *TestcaseMutation) LabProblemID() (r int, exists bool) {
	v := m.lab_problem
	if v == nil {
		return
	}
	return *v, true
}

// OldLabProblemID returns the old "lab_problem_id" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldLabProblemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabProblemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabProblemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabProblemID: %w", err)
	}
	return oldValue.LabProblemID, nil
}

// ResetLabProblemID resets all changes to the "lab_problem_id" field.
func (m *TestcaseMutation) ResetLabProblemID() {
	m.lab_problem = nil
}

// SetInput sets the "input" field.
func (m *TestcaseMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *TestcaseMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *TestcaseMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *TestcaseMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *TestcaseMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *TestcaseMutation) ResetOutput() {
	m.output = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestcaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestcaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestcaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestcaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestcaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestcaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearLabProblem clears the "lab_problem" edge to the Lab_Problem entity.
func (m *TestcaseMutation) ClearLabProblem() {
	m.clearedlab_problem = true
}

// LabProblemCleared reports if the "lab_problem" edge to the Lab_Problem entity was cleared.
func (m *TestcaseMutation) LabProblemCleared() bool {
	return m.clearedlab_problem
}

// LabProblemIDs returns the "lab_problem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LabProblemID instead. It exists only for internal usage by the builders.
func (m *TestcaseMutation) LabProblemIDs() (ids []int) {
	if id := m.lab_problem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLabProblem resets all changes to the "lab_problem" edge.
func (m *TestcaseMutation) ResetLabProblem() {
	m.lab_problem = nil
	m.clearedlab_problem = false
}

// AddTestcaseSubmissionIDs adds the "testcase_submissions" edge to the Testcase_Submission entity by ids.
func (m *TestcaseMutation) AddTestcaseSubmissionIDs(ids ...int) {
	if m.testcase_submissions == nil {
		m.testcase_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.testcase_submissions[ids[i]] = struct{}{}
	}
}

// ClearTestcaseSubmissions clears the "testcase_submissions" edge to the Testcase_Submission entity.
func (m *TestcaseMutation) ClearTestcaseSubmissions() {
	m.clearedtestcase_submissions = true
}

// TestcaseSubmissionsCleared reports if the "testcase_submissions" edge to the Testcase_Submission entity was cleared.
func (m *TestcaseMutation) TestcaseSubmissionsCleared() bool {
	return m.clearedtestcase_submissions
}

// RemoveTestcaseSubmissionIDs removes the "testcase_submissions" edge to the Testcase_Submission entity by IDs.
func (m *TestcaseMutation) RemoveTestcaseSubmissionIDs(ids ...int) {
	if m.removedtestcase_submissions == nil {
		m.removedtestcase_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.testcase_submissions, ids[i])
		m.removedtestcase_submissions[ids[i]] = struct{}{}
	}
}

// RemovedTestcaseSubmissions returns the removed IDs of the "testcase_submissions" edge to the Testcase_Submission entity.
func (m *TestcaseMutation) RemovedTestcaseSubmissionsIDs() (ids []int) {
	for id := range m.removedtestcase_submissions {
		ids = append(ids, id)
	}
	return
}

// TestcaseSubmissionsIDs returns the "testcase_submissions" edge IDs in the mutation.
func (m *TestcaseMutation) TestcaseSubmissionsIDs() (ids []int) {
	for id := range m.testcase_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetTestcaseSubmissions resets all changes to the "testcase_submissions" edge.
func (m *TestcaseMutation) ResetTestcaseSubmissions() {
	m.testcase_submissions = nil
	m.clearedtestcase_submissions = false
	m.removedtestcase_submissions = nil
}

// Where appends a list predicates to the TestcaseMutation builder.
func (m *TestcaseMutation) Where(ps ...predicate.Testcase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestcaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestcaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Testcase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestcaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestcaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Testcase).
func (m *TestcaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestcaseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.lab_problem != nil {
		fields = append(fields, testcase.FieldLabProblemID)
	}
	if m.input != nil {
		fields = append(fields, testcase.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, testcase.FieldOutput)
	}
	if m.created_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestcaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldLabProblemID:
		return m.LabProblemID()
	case testcase.FieldInput:
		return m.Input()
	case testcase.FieldOutput:
		return m.Output()
	case testcase.FieldCreatedAt:
		return m.CreatedAt()
	case testcase.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestcaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldLabProblemID:
		return m.OldLabProblemID(ctx)
	case testcase.FieldInput:
		return m.OldInput(ctx)
	case testcase.FieldOutput:
		return m.OldOutput(ctx)
	case testcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Testcase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldLabProblemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabProblemID(v)
		return nil
	case testcase.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case testcase.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case testcase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Testcase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestcaseMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestcaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Testcase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestcaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestcaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestcaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Testcase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestcaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldLabProblemID:
		m.ResetLabProblemID()
		return nil
	case testcase.FieldInput:
		m.ResetInput()
		return nil
	case testcase.FieldOutput:
		m.ResetOutput()
		return nil
	case testcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Testcase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestcaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lab_problem != nil {
		edges = append(edges, testcase.EdgeLabProblem)
	}
	if m.testcase_submissions != nil {
		edges = append(edges, testcase.EdgeTestcaseSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestcaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testcase.EdgeLabProblem:
		if id := m.lab_problem; id != nil {
			return []ent.Value{*id}
		}
	case testcase.EdgeTestcaseSubmissions:
		ids := make([]ent.Value, 0, len(m.testcase_submissions))
		for id := range m.testcase_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestcaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtestcase_submissions != nil {
		edges = append(edges, testcase.EdgeTestcaseSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestcaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case testcase.EdgeTestcaseSubmissions:
		ids := make([]ent.Value, 0, len(m.removedtestcase_submissions))
		for id := range m.removedtestcase_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestcaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlab_problem {
		edges = append(edges, testcase.EdgeLabProblem)
	}
	if m.clearedtestcase_submissions {
		edges = append(edges, testcase.EdgeTestcaseSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestcaseMutation) EdgeCleared(name string) bool {
	switch name {
	case testcase.EdgeLabProblem:
		return m.clearedlab_problem
	case testcase.EdgeTestcaseSubmissions:
		return m.clearedtestcase_submissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestcaseMutation) ClearEdge(name string) error {
	switch name {
	case testcase.EdgeLabProblem:
		m.ClearLabProblem()
		return nil
	}
	return fmt.Errorf("unknown Testcase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestcaseMutation) ResetEdge(name string) error {
	switch name {
	case testcase.EdgeLabProblem:
		m.ResetLabProblem()
		return nil
	case testcase.EdgeTestcaseSubmissions:
		m.ResetTestcaseSubmissions()
		return nil
	}
	return fmt.Errorf("unknown Testcase edge %s", name)
}

// TestcaseSubmissionMutation represents an operation that mutates the Testcase_Submission nodes in the graph.
type TestcaseSubmissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	input             *string
	expected_output   *string
	actual_output     *string
	is_passed         *bool
	score             *float64
	addscore          *float64
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	testcase          *int
	clearedtestcase   bool
	submission        *int
	clearedsubmission bool
	done              bool
	oldValue          func(context.Context) (*Testcase_Submission, error)
	predicates        []predicate.Testcase_Submission
}

var _ ent.Mutation = (*TestcaseSubmissionMutation)(nil)

// testcaseSubmissionOption allows management of the mutation configuration using functional options.
type testcaseSubmissionOption func(*TestcaseSubmissionMutation)

// newTestcaseSubmissionMutation creates new mutation for the Testcase_Submission entity.
func newTestcaseSubmissionMutation(c config, op Op, opts ...testcaseSubmissionOption) *TestcaseSubmissionMutation {
	m := &TestcaseSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeTestcaseSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestcase_SubmissionID sets the ID field of the mutation.
func withTestcase_SubmissionID(id int) testcaseSubmissionOption {
	return func(m *TestcaseSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Testcase_Submission
		)
		m.oldValue = func(ctx context.Context) (*Testcase_Submission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Testcase_Submission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestcase_Submission sets the old Testcase_Submission of the mutation.
func withTestcase_Submission(node *Testcase_Submission) testcaseSubmissionOption {
	return func(m *TestcaseSubmissionMutation) {
		m.oldValue = func(context.Context) (*Testcase_Submission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestcaseSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestcaseSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestcaseSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestcaseSubmissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Testcase_Submission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubmissionID sets the "submission_id" field.
func (m *TestcaseSubmissionMutation) SetSubmissionID(i int) {
	m.submission = &i
}

// SubmissionID returns the value of the "submission_id" field in the mutation.
func (m *TestcaseSubmissionMutation) SubmissionID() (r int, exists bool) {
	v := m.submission
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmissionID returns the old "submission_id" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldSubmissionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmissionID: %w", err)
	}
	return oldValue.SubmissionID, nil
}

// ResetSubmissionID resets all changes to the "submission_id" field.
func (m *TestcaseSubmissionMutation) ResetSubmissionID() {
	m.submission = nil
}

// SetTestcaseID sets the "testcase_id" field.
func (m *TestcaseSubmissionMutation) SetTestcaseID(i int) {
	m.testcase = &i
}

// TestcaseID returns the value of the "testcase_id" field in the mutation.
func (m *TestcaseSubmissionMutation) TestcaseID() (r int, exists bool) {
	v := m.testcase
	if v == nil {
		return
	}
	return *v, true
}

// OldTestcaseID returns the old "testcase_id" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldTestcaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestcaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestcaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestcaseID: %w", err)
	}
	return oldValue.TestcaseID, nil
}

// ResetTestcaseID resets all changes to the "testcase_id" field.
func (m *TestcaseSubmissionMutation) ResetTestcaseID() {
	m.testcase = nil
}

// SetInput sets the "input" field.
func (m *TestcaseSubmissionMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *TestcaseSubmissionMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *TestcaseSubmissionMutation) ResetInput() {
	m.input = nil
}

// SetExpectedOutput sets the "expected_output" field.
func (m *TestcaseSubmissionMutation) SetExpectedOutput(s string) {
	m.expected_output = &s
}

// ExpectedOutput returns the value of the "expected_output" field in the mutation.
func (m *TestcaseSubmissionMutation) ExpectedOutput() (r string, exists bool) {
	v := m.expected_output
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedOutput returns the old "expected_output" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldExpectedOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedOutput: %w", err)
	}
	return oldValue.ExpectedOutput, nil
}

// ResetExpectedOutput resets all changes to the "expected_output" field.
func (m *TestcaseSubmissionMutation) ResetExpectedOutput() {
	m.expected_output = nil
}

// SetActualOutput sets the "actual_output" field.
func (m *TestcaseSubmissionMutation) SetActualOutput(s string) {
	m.actual_output = &s
}

// ActualOutput returns the value of the "actual_output" field in the mutation.
func (m *TestcaseSubmissionMutation) ActualOutput() (r string, exists bool) {
	v := m.actual_output
	if v == nil {
		return
	}
	return *v, true
}

// OldActualOutput returns the old "actual_output" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldActualOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualOutput: %w", err)
	}
	return oldValue.ActualOutput, nil
}

// ResetActualOutput resets all changes to the "actual_output" field.
func (m *TestcaseSubmissionMutation) ResetActualOutput() {
	m.actual_output = nil
}

// SetIsPassed sets the "is_passed" field.
func (m *TestcaseSubmissionMutation) SetIsPassed(b bool) {
	m.is_passed = &b
}

// IsPassed returns the value of the "is_passed" field in the mutation.
func (m *TestcaseSubmissionMutation) IsPassed() (r bool, exists bool) {
	v := m.is_passed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPassed returns the old "is_passed" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldIsPassed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPassed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPassed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPassed: %w", err)
	}
	return oldValue.IsPassed, nil
}

// ResetIsPassed resets all changes to the "is_passed" field.
func (m *TestcaseSubmissionMutation) ResetIsPassed() {
	m.is_passed = nil
}

// SetScore sets the "score" field.
func (m *TestcaseSubmissionMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *TestcaseSubmissionMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *TestcaseSubmissionMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *TestcaseSubmissionMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *TestcaseSubmissionMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestcaseSubmissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestcaseSubmissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestcaseSubmissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestcaseSubmissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestcaseSubmissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Testcase_Submission entity.
// If the Testcase_Submission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSubmissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestcaseSubmissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTestcase clears the "testcase" edge to the Testcase entity.
func (m *TestcaseSubmissionMutation) ClearTestcase() {
	m.clearedtestcase = true
}

// TestcaseCleared reports if the "testcase" edge to the Testcase entity was cleared.
func (m *TestcaseSubmissionMutation) TestcaseCleared() bool {
	return m.clearedtestcase
}

// TestcaseIDs returns the "testcase" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TestcaseID instead. It exists only for internal usage by the builders.
func (m *TestcaseSubmissionMutation) TestcaseIDs() (ids []int) {
	if id := m.testcase; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTestcase resets all changes to the "testcase" edge.
func (m *TestcaseSubmissionMutation) ResetTestcase() {
	m.testcase = nil
	m.clearedtestcase = false
}

// ClearSubmission clears the "submission" edge to the Lab_Problem_Submission entity.
func (m *TestcaseSubmissionMutation) ClearSubmission() {
	m.clearedsubmission = true
}

// SubmissionCleared reports if the "submission" edge to the Lab_Problem_Submission entity was cleared.
func (m *TestcaseSubmissionMutation) SubmissionCleared() bool {
	return m.clearedsubmission
}

// SubmissionIDs returns the "submission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubmissionID instead. It exists only for internal usage by the builders.
func (m *TestcaseSubmissionMutation) SubmissionIDs() (ids []int) {
	if id := m.submission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubmission resets all changes to the "submission" edge.
func (m *TestcaseSubmissionMutation) ResetSubmission() {
	m.submission = nil
	m.clearedsubmission = false
}

// Where appends a list predicates to the TestcaseSubmissionMutation builder.
func (m *TestcaseSubmissionMutation) Where(ps ...predicate.Testcase_Submission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestcaseSubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestcaseSubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Testcase_Submission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestcaseSubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestcaseSubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Testcase_Submission).
func (m *TestcaseSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestcaseSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.submission != nil {
		fields = append(fields, testcase_submission.FieldSubmissionID)
	}
	if m.testcase != nil {
		fields = append(fields, testcase_submission.FieldTestcaseID)
	}
	if m.input != nil {
		fields = append(fields, testcase_submission.FieldInput)
	}
	if m.expected_output != nil {
		fields = append(fields, testcase_submission.FieldExpectedOutput)
	}
	if m.actual_output != nil {
		fields = append(fields, testcase_submission.FieldActualOutput)
	}
	if m.is_passed != nil {
		fields = append(fields, testcase_submission.FieldIsPassed)
	}
	if m.score != nil {
		fields = append(fields, testcase_submission.FieldScore)
	}
	if m.created_at != nil {
		fields = append(fields, testcase_submission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, testcase_submission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestcaseSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase_submission.FieldSubmissionID:
		return m.SubmissionID()
	case testcase_submission.FieldTestcaseID:
		return m.TestcaseID()
	case testcase_submission.FieldInput:
		return m.Input()
	case testcase_submission.FieldExpectedOutput:
		return m.ExpectedOutput()
	case testcase_submission.FieldActualOutput:
		return m.ActualOutput()
	case testcase_submission.FieldIsPassed:
		return m.IsPassed()
	case testcase_submission.FieldScore:
		return m.Score()
	case testcase_submission.FieldCreatedAt:
		return m.CreatedAt()
	case testcase_submission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestcaseSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase_submission.FieldSubmissionID:
		return m.OldSubmissionID(ctx)
	case testcase_submission.FieldTestcaseID:
		return m.OldTestcaseID(ctx)
	case testcase_submission.FieldInput:
		return m.OldInput(ctx)
	case testcase_submission.FieldExpectedOutput:
		return m.OldExpectedOutput(ctx)
	case testcase_submission.FieldActualOutput:
		return m.OldActualOutput(ctx)
	case testcase_submission.FieldIsPassed:
		return m.OldIsPassed(ctx)
	case testcase_submission.FieldScore:
		return m.OldScore(ctx)
	case testcase_submission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcase_submission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Testcase_Submission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase_submission.FieldSubmissionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmissionID(v)
		return nil
	case testcase_submission.FieldTestcaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestcaseID(v)
		return nil
	case testcase_submission.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case testcase_submission.FieldExpectedOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedOutput(v)
		return nil
	case testcase_submission.FieldActualOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualOutput(v)
		return nil
	case testcase_submission.FieldIsPassed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPassed(v)
		return nil
	case testcase_submission.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case testcase_submission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcase_submission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Testcase_Submission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestcaseSubmissionMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, testcase_submission.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestcaseSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase_submission.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase_submission.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown Testcase_Submission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestcaseSubmissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestcaseSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestcaseSubmissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Testcase_Submission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestcaseSubmissionMutation) ResetField(name string) error {
	switch name {
	case testcase_submission.FieldSubmissionID:
		m.ResetSubmissionID()
		return nil
	case testcase_submission.FieldTestcaseID:
		m.ResetTestcaseID()
		return nil
	case testcase_submission.FieldInput:
		m.ResetInput()
		return nil
	case testcase_submission.FieldExpectedOutput:
		m.ResetExpectedOutput()
		return nil
	case testcase_submission.FieldActualOutput:
		m.ResetActualOutput()
		return nil
	case testcase_submission.FieldIsPassed:
		m.ResetIsPassed()
		return nil
	case testcase_submission.FieldScore:
		m.ResetScore()
		return nil
	case testcase_submission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcase_submission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Testcase_Submission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestcaseSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.testcase != nil {
		edges = append(edges, testcase_submission.EdgeTestcase)
	}
	if m.submission != nil {
		edges = append(edges, testcase_submission.EdgeSubmission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestcaseSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testcase_submission.EdgeTestcase:
		if id := m.testcase; id != nil {
			return []ent.Value{*id}
		}
	case testcase_submission.EdgeSubmission:
		if id := m.submission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestcaseSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestcaseSubmissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestcaseSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtestcase {
		edges = append(edges, testcase_submission.EdgeTestcase)
	}
	if m.clearedsubmission {
		edges = append(edges, testcase_submission.EdgeSubmission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestcaseSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case testcase_submission.EdgeTestcase:
		return m.clearedtestcase
	case testcase_submission.EdgeSubmission:
		return m.clearedsubmission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestcaseSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case testcase_submission.EdgeTestcase:
		m.ClearTestcase()
		return nil
	case testcase_submission.EdgeSubmission:
		m.ClearSubmission()
		return nil
	}
	return fmt.Errorf("unknown Testcase_Submission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestcaseSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case testcase_submission.EdgeTestcase:
		m.ResetTestcase()
		return nil
	case testcase_submission.EdgeSubmission:
		m.ResetSubmission()
		return nil
	}
	return fmt.Errorf("unknown Testcase_Submission edge %s", name)
}

// TopicMutation represents an operation that mutates the Topic nodes in the graph.
type TopicMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	course        *int
	clearedcourse bool
	files         map[int]struct{}
	removedfiles  map[int]struct{}
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*Topic, error)
	predicates    []predicate.Topic
}

var _ ent.Mutation = (*TopicMutation)(nil)

// topicOption allows management of the mutation configuration using functional options.
type topicOption func(*TopicMutation)

// newTopicMutation creates new mutation for the Topic entity.
func newTopicMutation(c config, op Op, opts ...topicOption) *TopicMutation {
	m := &TopicMutation{
		config:        c,
		op:            op,
		typ:           TypeTopic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicID sets the ID field of the mutation.
func withTopicID(id int) topicOption {
	return func(m *TopicMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic
		)
		m.oldValue = func(ctx context.Context) (*Topic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic sets the old Topic of the mutation.
func withTopic(node *Topic) topicOption {
	return func(m *TopicMutation) {
		m.oldValue = func(context.Context) (*Topic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCourseID sets the "course_id" field.
func (m *TopicMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *TopicMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *TopicMutation) ResetCourseID() {
	m.course = nil
}

// SetName sets the "name" field.
func (m *TopicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TopicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TopicMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TopicMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TopicMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TopicMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TopicMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TopicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TopicMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *TopicMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *TopicMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *TopicMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TopicMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddFileIDs adds the "files" edge to the Topic_File_Mats entity by ids.
func (m *TopicMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the Topic_File_Mats entity.
func (m *TopicMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the Topic_File_Mats entity was cleared.
func (m *TopicMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the Topic_File_Mats entity by IDs.
func (m *TopicMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the Topic_File_Mats entity.
func (m *TopicMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *TopicMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *TopicMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the TopicMutation builder.
func (m *TopicMutation) Where(ps ...predicate.Topic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Topic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Topic).
func (m *TopicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.course != nil {
		fields = append(fields, topic.FieldCourseID)
	}
	if m.name != nil {
		fields = append(fields, topic.FieldName)
	}
	if m.description != nil {
		fields = append(fields, topic.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, topic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, topic.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic.FieldCourseID:
		return m.CourseID()
	case topic.FieldName:
		return m.Name()
	case topic.FieldDescription:
		return m.Description()
	case topic.FieldCreatedAt:
		return m.CreatedAt()
	case topic.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic.FieldCourseID:
		return m.OldCourseID(ctx)
	case topic.FieldName:
		return m.OldName(ctx)
	case topic.FieldDescription:
		return m.OldDescription(ctx)
	case topic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Topic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	case topic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case topic.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case topic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Topic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicMutation) ResetField(name string) error {
	switch name {
	case topic.FieldCourseID:
		m.ResetCourseID()
		return nil
	case topic.FieldName:
		m.ResetName()
		return nil
	case topic.FieldDescription:
		m.ResetDescription()
		return nil
	case topic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.course != nil {
		edges = append(edges, topic.EdgeCourse)
	}
	if m.files != nil {
		edges = append(edges, topic.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case topic.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfiles != nil {
		edges = append(edges, topic.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcourse {
		edges = append(edges, topic.EdgeCourse)
	}
	if m.clearedfiles {
		edges = append(edges, topic.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicMutation) EdgeCleared(name string) bool {
	switch name {
	case topic.EdgeCourse:
		return m.clearedcourse
	case topic.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicMutation) ClearEdge(name string) error {
	switch name {
	case topic.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Topic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicMutation) ResetEdge(name string) error {
	switch name {
	case topic.EdgeCourse:
		m.ResetCourse()
		return nil
	case topic.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Topic edge %s", name)
}

// TopicFileMatsMutation represents an operation that mutates the Topic_File_Mats nodes in the graph.
type TopicFileMatsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	file_path     *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	topic         *int
	clearedtopic  bool
	done          bool
	oldValue      func(context.Context) (*Topic_File_Mats, error)
	predicates    []predicate.Topic_File_Mats
}

var _ ent.Mutation = (*TopicFileMatsMutation)(nil)

// topicFileMatsOption allows management of the mutation configuration using functional options.
type topicFileMatsOption func(*TopicFileMatsMutation)

// newTopicFileMatsMutation creates new mutation for the Topic_File_Mats entity.
func newTopicFileMatsMutation(c config, op Op, opts ...topicFileMatsOption) *TopicFileMatsMutation {
	m := &TopicFileMatsMutation{
		config:        c,
		op:            op,
		typ:           TypeTopicFileMats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopic_File_MatsID sets the ID field of the mutation.
func withTopic_File_MatsID(id int) topicFileMatsOption {
	return func(m *TopicFileMatsMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic_File_Mats
		)
		m.oldValue = func(ctx context.Context) (*Topic_File_Mats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic_File_Mats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic_File_Mats sets the old Topic_File_Mats of the mutation.
func withTopic_File_Mats(node *Topic_File_Mats) topicFileMatsOption {
	return func(m *TopicFileMatsMutation) {
		m.oldValue = func(context.Context) (*Topic_File_Mats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicFileMatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicFileMatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicFileMatsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicFileMatsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic_File_Mats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTopicID sets the "topic_id" field.
func (m *TopicFileMatsMutation) SetTopicID(i int) {
	m.topic = &i
}

// TopicID returns the value of the "topic_id" field in the mutation.
func (m *TopicFileMatsMutation) TopicID() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicID returns the old "topic_id" field's value of the Topic_File_Mats entity.
// If the Topic_File_Mats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicFileMatsMutation) OldTopicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicID: %w", err)
	}
	return oldValue.TopicID, nil
}

// ResetTopicID resets all changes to the "topic_id" field.
func (m *TopicFileMatsMutation) ResetTopicID() {
	m.topic = nil
}

// SetName sets the "name" field.
func (m *TopicFileMatsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TopicFileMatsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Topic_File_Mats entity.
// If the Topic_File_Mats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicFileMatsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TopicFileMatsMutation) ResetName() {
	m.name = nil
}

// SetFilePath sets the "file_path" field.
func (m *TopicFileMatsMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *TopicFileMatsMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Topic_File_Mats entity.
// If the Topic_File_Mats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicFileMatsMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *TopicFileMatsMutation) ResetFilePath() {
	m.file_path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TopicFileMatsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopicFileMatsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Topic_File_Mats entity.
// If the Topic_File_Mats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicFileMatsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopicFileMatsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *TopicFileMatsMutation) ClearTopic() {
	m.clearedtopic = true
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *TopicFileMatsMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *TopicFileMatsMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *TopicFileMatsMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the TopicFileMatsMutation builder.
func (m *TopicFileMatsMutation) Where(ps ...predicate.Topic_File_Mats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicFileMatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicFileMatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Topic_File_Mats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicFileMatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicFileMatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Topic_File_Mats).
func (m *TopicFileMatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicFileMatsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.topic != nil {
		fields = append(fields, topic_file_mats.FieldTopicID)
	}
	if m.name != nil {
		fields = append(fields, topic_file_mats.FieldName)
	}
	if m.file_path != nil {
		fields = append(fields, topic_file_mats.FieldFilePath)
	}
	if m.created_at != nil {
		fields = append(fields, topic_file_mats.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicFileMatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic_file_mats.FieldTopicID:
		return m.TopicID()
	case topic_file_mats.FieldName:
		return m.Name()
	case topic_file_mats.FieldFilePath:
		return m.FilePath()
	case topic_file_mats.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicFileMatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic_file_mats.FieldTopicID:
		return m.OldTopicID(ctx)
	case topic_file_mats.FieldName:
		return m.OldName(ctx)
	case topic_file_mats.FieldFilePath:
		return m.OldFilePath(ctx)
	case topic_file_mats.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Topic_File_Mats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicFileMatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic_file_mats.FieldTopicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	case topic_file_mats.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case topic_file_mats.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case topic_file_mats.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Topic_File_Mats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicFileMatsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicFileMatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicFileMatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic_File_Mats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicFileMatsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicFileMatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicFileMatsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Topic_File_Mats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicFileMatsMutation) ResetField(name string) error {
	switch name {
	case topic_file_mats.FieldTopicID:
		m.ResetTopicID()
		return nil
	case topic_file_mats.FieldName:
		m.ResetName()
		return nil
	case topic_file_mats.FieldFilePath:
		m.ResetFilePath()
		return nil
	case topic_file_mats.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Topic_File_Mats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicFileMatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.topic != nil {
		edges = append(edges, topic_file_mats.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicFileMatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic_file_mats.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicFileMatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicFileMatsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicFileMatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtopic {
		edges = append(edges, topic_file_mats.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicFileMatsMutation) EdgeCleared(name string) bool {
	switch name {
	case topic_file_mats.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicFileMatsMutation) ClearEdge(name string) error {
	switch name {
	case topic_file_mats.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown Topic_File_Mats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicFileMatsMutation) ResetEdge(name string) error {
	switch name {
	case topic_file_mats.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown Topic_File_Mats edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	username                       *string
	email                          *string
	password                       *string
	name                           *string
	image_path                     *string
	last_online                    *time.Time
	created_at                     *time.Time
	updated_at                     *time.Time
	is_admin                       *bool
	clearedFields                  map[string]struct{}
	courses                        map[int]struct{}
	removedcourses                 map[int]struct{}
	clearedcourses                 bool
	owned_classes                  map[int]struct{}
	removedowned_classes           map[int]struct{}
	clearedowned_classes           bool
	joined_classes                 map[int]struct{}
	removedjoined_classes          map[int]struct{}
	clearedjoined_classes          bool
	owned_posts                    map[int]struct{}
	removedowned_posts             map[int]struct{}
	clearedowned_posts             bool
	lab_problem_submissions        map[int]struct{}
	removedlab_problem_submissions map[int]struct{}
	clearedlab_problem_submissions bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetImagePath sets the "image_path" field.
func (m *UserMutation) SetImagePath(s string) {
	m.image_path = &s
}

// ImagePath returns the value of the "image_path" field in the mutation.
func (m *UserMutation) ImagePath() (r string, exists bool) {
	v := m.image_path
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePath returns the old "image_path" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldImagePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePath: %w", err)
	}
	return oldValue.ImagePath, nil
}

// ClearImagePath clears the value of the "image_path" field.
func (m *UserMutation) ClearImagePath() {
	m.image_path = nil
	m.clearedFields[user.FieldImagePath] = struct{}{}
}

// ImagePathCleared returns if the "image_path" field was cleared in this mutation.
func (m *UserMutation) ImagePathCleared() bool {
	_, ok := m.clearedFields[user.FieldImagePath]
	return ok
}

// ResetImagePath resets all changes to the "image_path" field.
func (m *UserMutation) ResetImagePath() {
	m.image_path = nil
	delete(m.clearedFields, user.FieldImagePath)
}

// SetLastOnline sets the "last_online" field.
func (m *UserMutation) SetLastOnline(t time.Time) {
	m.last_online = &t
}

// LastOnline returns the value of the "last_online" field in the mutation.
func (m *UserMutation) LastOnline() (r time.Time, exists bool) {
	v := m.last_online
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOnline returns the old "last_online" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastOnline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOnline: %w", err)
	}
	return oldValue.LastOnline, nil
}

// ClearLastOnline clears the value of the "last_online" field.
func (m *UserMutation) ClearLastOnline() {
	m.last_online = nil
	m.clearedFields[user.FieldLastOnline] = struct{}{}
}

// LastOnlineCleared returns if the "last_online" field was cleared in this mutation.
func (m *UserMutation) LastOnlineCleared() bool {
	_, ok := m.clearedFields[user.FieldLastOnline]
	return ok
}

// ResetLastOnline resets all changes to the "last_online" field.
func (m *UserMutation) ResetLastOnline() {
	m.last_online = nil
	delete(m.clearedFields, user.FieldLastOnline)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *UserMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *UserMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *UserMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *UserMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *UserMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *UserMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *UserMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// AddOwnedClassIDs adds the "owned_classes" edge to the Class entity by ids.
func (m *UserMutation) AddOwnedClassIDs(ids ...int) {
	if m.owned_classes == nil {
		m.owned_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_classes[ids[i]] = struct{}{}
	}
}

// ClearOwnedClasses clears the "owned_classes" edge to the Class entity.
func (m *UserMutation) ClearOwnedClasses() {
	m.clearedowned_classes = true
}

// OwnedClassesCleared reports if the "owned_classes" edge to the Class entity was cleared.
func (m *UserMutation) OwnedClassesCleared() bool {
	return m.clearedowned_classes
}

// RemoveOwnedClassIDs removes the "owned_classes" edge to the Class entity by IDs.
func (m *UserMutation) RemoveOwnedClassIDs(ids ...int) {
	if m.removedowned_classes == nil {
		m.removedowned_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_classes, ids[i])
		m.removedowned_classes[ids[i]] = struct{}{}
	}
}

// RemovedOwnedClasses returns the removed IDs of the "owned_classes" edge to the Class entity.
func (m *UserMutation) RemovedOwnedClassesIDs() (ids []int) {
	for id := range m.removedowned_classes {
		ids = append(ids, id)
	}
	return
}

// OwnedClassesIDs returns the "owned_classes" edge IDs in the mutation.
func (m *UserMutation) OwnedClassesIDs() (ids []int) {
	for id := range m.owned_classes {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedClasses resets all changes to the "owned_classes" edge.
func (m *UserMutation) ResetOwnedClasses() {
	m.owned_classes = nil
	m.clearedowned_classes = false
	m.removedowned_classes = nil
}

// AddJoinedClassIDs adds the "joined_classes" edge to the Class_User_Role entity by ids.
func (m *UserMutation) AddJoinedClassIDs(ids ...int) {
	if m.joined_classes == nil {
		m.joined_classes = make(map[int]struct{})
	}
	for i := range ids {
		m.joined_classes[ids[i]] = struct{}{}
	}
}

// ClearJoinedClasses clears the "joined_classes" edge to the Class_User_Role entity.
func (m *UserMutation) ClearJoinedClasses() {
	m.clearedjoined_classes = true
}

// JoinedClassesCleared reports if the "joined_classes" edge to the Class_User_Role entity was cleared.
func (m *UserMutation) JoinedClassesCleared() bool {
	return m.clearedjoined_classes
}

// RemoveJoinedClassIDs removes the "joined_classes" edge to the Class_User_Role entity by IDs.
func (m *UserMutation) RemoveJoinedClassIDs(ids ...int) {
	if m.removedjoined_classes == nil {
		m.removedjoined_classes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.joined_classes, ids[i])
		m.removedjoined_classes[ids[i]] = struct{}{}
	}
}

// RemovedJoinedClasses returns the removed IDs of the "joined_classes" edge to the Class_User_Role entity.
func (m *UserMutation) RemovedJoinedClassesIDs() (ids []int) {
	for id := range m.removedjoined_classes {
		ids = append(ids, id)
	}
	return
}

// JoinedClassesIDs returns the "joined_classes" edge IDs in the mutation.
func (m *UserMutation) JoinedClassesIDs() (ids []int) {
	for id := range m.joined_classes {
		ids = append(ids, id)
	}
	return
}

// ResetJoinedClasses resets all changes to the "joined_classes" edge.
func (m *UserMutation) ResetJoinedClasses() {
	m.joined_classes = nil
	m.clearedjoined_classes = false
	m.removedjoined_classes = nil
}

// AddOwnedPostIDs adds the "owned_posts" edge to the Post entity by ids.
func (m *UserMutation) AddOwnedPostIDs(ids ...int) {
	if m.owned_posts == nil {
		m.owned_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_posts[ids[i]] = struct{}{}
	}
}

// ClearOwnedPosts clears the "owned_posts" edge to the Post entity.
func (m *UserMutation) ClearOwnedPosts() {
	m.clearedowned_posts = true
}

// OwnedPostsCleared reports if the "owned_posts" edge to the Post entity was cleared.
func (m *UserMutation) OwnedPostsCleared() bool {
	return m.clearedowned_posts
}

// RemoveOwnedPostIDs removes the "owned_posts" edge to the Post entity by IDs.
func (m *UserMutation) RemoveOwnedPostIDs(ids ...int) {
	if m.removedowned_posts == nil {
		m.removedowned_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_posts, ids[i])
		m.removedowned_posts[ids[i]] = struct{}{}
	}
}

// RemovedOwnedPosts returns the removed IDs of the "owned_posts" edge to the Post entity.
func (m *UserMutation) RemovedOwnedPostsIDs() (ids []int) {
	for id := range m.removedowned_posts {
		ids = append(ids, id)
	}
	return
}

// OwnedPostsIDs returns the "owned_posts" edge IDs in the mutation.
func (m *UserMutation) OwnedPostsIDs() (ids []int) {
	for id := range m.owned_posts {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedPosts resets all changes to the "owned_posts" edge.
func (m *UserMutation) ResetOwnedPosts() {
	m.owned_posts = nil
	m.clearedowned_posts = false
	m.removedowned_posts = nil
}

// AddLabProblemSubmissionIDs adds the "lab_problem_submissions" edge to the Lab_Problem_Submission entity by ids.
func (m *UserMutation) AddLabProblemSubmissionIDs(ids ...int) {
	if m.lab_problem_submissions == nil {
		m.lab_problem_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.lab_problem_submissions[ids[i]] = struct{}{}
	}
}

// ClearLabProblemSubmissions clears the "lab_problem_submissions" edge to the Lab_Problem_Submission entity.
func (m *UserMutation) ClearLabProblemSubmissions() {
	m.clearedlab_problem_submissions = true
}

// LabProblemSubmissionsCleared reports if the "lab_problem_submissions" edge to the Lab_Problem_Submission entity was cleared.
func (m *UserMutation) LabProblemSubmissionsCleared() bool {
	return m.clearedlab_problem_submissions
}

// RemoveLabProblemSubmissionIDs removes the "lab_problem_submissions" edge to the Lab_Problem_Submission entity by IDs.
func (m *UserMutation) RemoveLabProblemSubmissionIDs(ids ...int) {
	if m.removedlab_problem_submissions == nil {
		m.removedlab_problem_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lab_problem_submissions, ids[i])
		m.removedlab_problem_submissions[ids[i]] = struct{}{}
	}
}

// RemovedLabProblemSubmissions returns the removed IDs of the "lab_problem_submissions" edge to the Lab_Problem_Submission entity.
func (m *UserMutation) RemovedLabProblemSubmissionsIDs() (ids []int) {
	for id := range m.removedlab_problem_submissions {
		ids = append(ids, id)
	}
	return
}

// LabProblemSubmissionsIDs returns the "lab_problem_submissions" edge IDs in the mutation.
func (m *UserMutation) LabProblemSubmissionsIDs() (ids []int) {
	for id := range m.lab_problem_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetLabProblemSubmissions resets all changes to the "lab_problem_submissions" edge.
func (m *UserMutation) ResetLabProblemSubmissions() {
	m.lab_problem_submissions = nil
	m.clearedlab_problem_submissions = false
	m.removedlab_problem_submissions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.image_path != nil {
		fields = append(fields, user.FieldImagePath)
	}
	if m.last_online != nil {
		fields = append(fields, user.FieldLastOnline)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldName:
		return m.Name()
	case user.FieldImagePath:
		return m.ImagePath()
	case user.FieldLastOnline:
		return m.LastOnline()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldImagePath:
		return m.OldImagePath(ctx)
	case user.FieldLastOnline:
		return m.OldLastOnline(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldImagePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePath(v)
		return nil
	case user.FieldLastOnline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOnline(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldImagePath) {
		fields = append(fields, user.FieldImagePath)
	}
	if m.FieldCleared(user.FieldLastOnline) {
		fields = append(fields, user.FieldLastOnline)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldImagePath:
		m.ClearImagePath()
		return nil
	case user.FieldLastOnline:
		m.ClearLastOnline()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldImagePath:
		m.ResetImagePath()
		return nil
	case user.FieldLastOnline:
		m.ResetLastOnline()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.courses != nil {
		edges = append(edges, user.EdgeCourses)
	}
	if m.owned_classes != nil {
		edges = append(edges, user.EdgeOwnedClasses)
	}
	if m.joined_classes != nil {
		edges = append(edges, user.EdgeJoinedClasses)
	}
	if m.owned_posts != nil {
		edges = append(edges, user.EdgeOwnedPosts)
	}
	if m.lab_problem_submissions != nil {
		edges = append(edges, user.EdgeLabProblemSubmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedClasses:
		ids := make([]ent.Value, 0, len(m.owned_classes))
		for id := range m.owned_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoinedClasses:
		ids := make([]ent.Value, 0, len(m.joined_classes))
		for id := range m.joined_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedPosts:
		ids := make([]ent.Value, 0, len(m.owned_posts))
		for id := range m.owned_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLabProblemSubmissions:
		ids := make([]ent.Value, 0, len(m.lab_problem_submissions))
		for id := range m.lab_problem_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcourses != nil {
		edges = append(edges, user.EdgeCourses)
	}
	if m.removedowned_classes != nil {
		edges = append(edges, user.EdgeOwnedClasses)
	}
	if m.removedjoined_classes != nil {
		edges = append(edges, user.EdgeJoinedClasses)
	}
	if m.removedowned_posts != nil {
		edges = append(edges, user.EdgeOwnedPosts)
	}
	if m.removedlab_problem_submissions != nil {
		edges = append(edges, user.EdgeLabProblemSubmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedClasses:
		ids := make([]ent.Value, 0, len(m.removedowned_classes))
		for id := range m.removedowned_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoinedClasses:
		ids := make([]ent.Value, 0, len(m.removedjoined_classes))
		for id := range m.removedjoined_classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedPosts:
		ids := make([]ent.Value, 0, len(m.removedowned_posts))
		for id := range m.removedowned_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLabProblemSubmissions:
		ids := make([]ent.Value, 0, len(m.removedlab_problem_submissions))
		for id := range m.removedlab_problem_submissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcourses {
		edges = append(edges, user.EdgeCourses)
	}
	if m.clearedowned_classes {
		edges = append(edges, user.EdgeOwnedClasses)
	}
	if m.clearedjoined_classes {
		edges = append(edges, user.EdgeJoinedClasses)
	}
	if m.clearedowned_posts {
		edges = append(edges, user.EdgeOwnedPosts)
	}
	if m.clearedlab_problem_submissions {
		edges = append(edges, user.EdgeLabProblemSubmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCourses:
		return m.clearedcourses
	case user.EdgeOwnedClasses:
		return m.clearedowned_classes
	case user.EdgeJoinedClasses:
		return m.clearedjoined_classes
	case user.EdgeOwnedPosts:
		return m.clearedowned_posts
	case user.EdgeLabProblemSubmissions:
		return m.clearedlab_problem_submissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCourses:
		m.ResetCourses()
		return nil
	case user.EdgeOwnedClasses:
		m.ResetOwnedClasses()
		return nil
	case user.EdgeJoinedClasses:
		m.ResetJoinedClasses()
		return nil
	case user.EdgeOwnedPosts:
		m.ResetOwnedPosts()
		return nil
	case user.EdgeLabProblemSubmissions:
		m.ResetLabProblemSubmissions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
